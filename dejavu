#!/usr/bin/python3
# DéjàVu GPT-3 Terminal
# Linux terminal interface for GPT-3
# Gary Dean garydean@okusi.id
# https://github.com/GaryDean/dejavu.ai.git
import atexit
import datetime
import json
import openai
import os
import random
import re
import readline
import shutil
import subprocess
import sys
import textwrap
import time
from colorama import init, Fore, Back, Style
init()

ScriptName = sys.argv.pop(0)
try: 
  realfile = os.readlink(ScriptName)
except:
  realfile = ScriptName
ScriptName = os.path.basename(realfile)
REPOSITORY='https://github.com/GaryDean/dejavu.ai.git'
HomeDir=os.path.expanduser('~')
UserHome=HomeDir+'/.'+ScriptName 
os.makedirs(UserHome, exist_ok=True)
UserSysName = os.getenv('USER')
if UserSysName == '': UserSysName = os.getenv('USER_NAME')
ScriptDir = '/usr/share/dejavu.ai'

# generic functions
def is_numeric(string):
  try:
    float(string)
    return True
  except ValueError: return False

def int_list(input_string, minVal, maxVal, revSort=False):
  range_list = []
  try:
    numlist = input_string.split(',')
    for numC in numlist:
      if numC.strip() == '': continue
      if '-' in numC:
        stnum, endnum = numC.split('-')
        if stnum == '':   stnum = int(minVal)
        if endnum == '':  endnum   = int(maxVal)
        stnum, endnum = int(stnum), int(endnum)
        if stnum < minVal or endnum > maxVal: 
          printerr('Error out of range'+str(stnum)+'-'+str(endnum))
          continue
        range_list += range(stnum, endnum+1)
      else:
        if int(numC) < minVal or int(numC) > maxVal: continue
        range_list.append(int(numC))
  except: 
    printerr('Exception error in int_list.')
    return False
  if len(range_list) == 0: return False
  range_list = list(set(range_list))
  range_list.sort()
  if revSort: return range_list[::-1]
  else:       return range_list

useColor = True
def printerr(*args, **kwargs):
  output=kwargs.get('file', sys.stderr)
  if useColor: 
    print(kwargs.get('color', Fore.RED) + kwargs.get('style', Style.NORMAL), end='', file=output)
  for arg in args: 
    print(kwargs.get('prefix', '!!')+arg, end=kwargs.get('end', '\n'), file=output)
  if useColor: 
    print(Style.RESET_ALL, end='', file=output)
def printinfo(*args, **kwargs):
  output=kwargs.get('file', sys.stdout)
  if useColor: 
    print(kwargs.get('color', Fore.WHITE) + kwargs.get('style', Style.DIM), end='', file=output)
  for arg in args: 
    print(kwargs.get('prefix', '# ')+arg, end=kwargs.get('end', '\n'), file=output)
  if useColor: 
    print(Style.RESET_ALL, end='', file=output)
def printstd(*args, **kwargs):
  output=kwargs.get('file', sys.stdout)
  if useColor: 
    print(kwargs.get('color', Fore.WHITE) + kwargs.get('style', Style.NORMAL), end='', file=output)
  for arg in args: 
    print(arg, end=kwargs.get('end', '\n'), file=output)
  if useColor: 
    print(Style.RESET_ALL, end='', file=output)


def file_get_contents(filepath):
    with open(filepath, 'r', encoding='utf-8') as infile:
        return infile.read()
def file_put_contents(filename, string, mode='w'):
    with open(filename, mode) as f:
        f.write(string)

# Process command line and define ConvFile to use
Version = file_get_contents(ScriptDir+'/dejavu.version').strip()
ConvFile = ''
cmdTypeAhead = []
cmdExit = 0
Verbose = True
while len(sys.argv) > 0:
  arg = sys.argv.pop(0).strip()
  if not arg: continue
  if arg in ['-u', '--upgrade', '--update']:
    tempdir = "/tmp/{0}-upgrade-{1}".format(ScriptName, random.randint(0, 9999))
    os.mkdir(tempdir); os.chdir(tempdir)
    qqq = "-{0}".format('v' if Verbose else 'q')
    subprocess.call(['git', 'clone', qqq, REPOSITORY, tempdir])
    cmd = tempdir + '/' + ScriptName + '.install'
    args = [ cmd, qqq ]
    os.execvp(cmd, args)
    exit()
  elif arg in ['-V', '--version']:
    print(ScriptName+' vs '+Version); exit()
  elif arg in ['-v', '--verbose']:
    Verbose = 1
  elif arg in ['-q', '--quiet']:
    Verbose = 0
  elif arg in ['-l', '--list']:
    for file in os.listdir(UserHome):
      if file.endswith('.'+ScriptName+'.txt'):
        filesize = os.stat(UserHome+'/'+file).st_size
        modified_date = datetime.datetime.fromtimestamp(os.stat(UserHome+'/'+file).st_mtime)
        print('{:12s} {:7.2f}KB {:20s}'.format(file[:-(5+len(ScriptName))], filesize/1024, modified_date.strftime('%Y-%m-%d %H:%M:%S')))
    exit()

  elif arg in ['-c', '--command']:
    if len(sys.argv) > 0:
      cmdTypeAhead.append(sys.argv.pop(0))
    else:
      printerr('Command was not specified for', arg)
      exit()

  elif arg in ['-f', '--cmd-file']:
    if len(sys.argv) == 0:
      printerr('Command File was not specified for', arg)
      exit()
    file = sys.argv.pop(0)
    if not '.dejavu.cmd' in file: file += '.dejavu.cmd'
    if not '/' in file: file = UserHome + '/' + file
    if not os.path.exists(file):
      printerr('File \''+file+'\' does not exist.')
      exit()
    lines = file_get_contents(file).split('\n')
    lne   = ''
    blanklines = 0
    for line in lines:
      if line:
        if line[0] == '#': continue
        blanklines = 0
        lne += (line[0:-1] if line[-1] == '\\' else line + '\n')
        continue
      else:
        blanklines += 1
        if blanklines < 2:
          if lne: lne += '\n'
          continue
      lne = lne.rstrip('\r\n')
      #if lne: print('['+lne+']')
      if lne: cmdTypeAhead.append(lne)
      lne = ''
      blanklines = 0
    lne = lne.rstrip('\r\n')
    #if lne: print('['+lne+']')
    if lne: cmdTypeAhead.append(lne)

  elif arg in ['-x', '--exit']:
      Verbose = 0
      cmdExit = 1

  elif arg in ['-C', '--no-color']:
    useColor = False

  elif arg in ['-h', '-?', '--help']:
    subprocess.run(['less', ScriptDir+'/'+ScriptName+'-synopsis.txt'])
    exit()
  # de-aggregate aggregated short options
  elif re.match(r'^-[cvqVh]', arg):
      sys.argv = [''] + ['-%s' % c for c in arg[1:]] + sys.argv
  elif re.match(r'^--', arg):
      printerr('Invalid option '+ arg); exit()
  elif arg[0:1] == '-':
      printerr('Invalid option '+ arg); exit()
  else:
    ConvFile = arg

# Conversation file validation and default
#if len(sys.argv) > 1: 
#  ConvFile = sys.argv[1]
#else: 
if len(ConvFile) == 0: 
  ConvFile = UserHome+'/conversation.dejavu.txt'
  if not os.path.exists(ConvFile):
    string = file_get_contents(ScriptDir+'/conversation.dejavu.txt')
    match = re.search(r'USER_NAME=(\w+)', string)
    if match:
      string = re.sub(r'USER_NAME=\w+', 'USER_NAME='+UserSysName.upper(), string)
    file_put_contents(UserHome+'/conversation.dejavu.txt', string)
if not os.path.exists(ConvFile):
  if os.path.exists(UserHome+'/'+ConvFile):
    ConvFile = UserHome+'/'+ConvFile
  elif os.path.exists(UserHome+'/'+ConvFile+'.dejavu.txt'):
    ConvFile = UserHome+'/'+ConvFile+'.dejavu.txt'
  else:
    printerr('DéjàVu conversation file "' + ConvFile + '" does not exist!')
    exit()
ConvFileName = os.path.basename(ConvFile)

# readline() history
historyFile = UserHome+'/'+ConvFileName.replace('.txt', '.history')
try:
    readline.read_history_file(historyFile)
    readline.set_history_length(200)
except FileNotFoundError:
    file_put_contents(historyFile, '')

atexit.register(readline.write_history_file, historyFile)

# Get the openai API key
try:  openai.api_key = os.environ['OPENAI_API_KEY']
except KeyError:
  printerr('Environment variable OPENAI_API_KEY is not defined '+str(KeyError))
  printinfo([ 
    'Go to https://openai.com/api for your own API key.',
    ':~$ export OPENAI_API_KEY="your_key"',
    'If you set up your openai account as an organization, you will also have to set OPENAI_ORGANIZATION_ID',
    ':~$ export OPENAI_ORGANIZATION_ID="your_organization"',
    'Both these environment variables should be set in your ~/.bashrc file.' ])
  exit()

try:  openai.organization = os.environ['OPENAI_ORGANIZATION_ID']
except: openai.organization = ''

# open up the Conversation file
value_list = []
with open(ConvFile, 'r') as f:
  lines = f.readlines()
  params = {}
  inprompt = False
  for line in lines:
    if line.strip() == '' and not inprompt: continue
    if line[0] == '#': continue
    if inprompt:
      if line == 'endprompt\n':
        inprompt = False
        value = ''.join(value_list)
        params[key] = value.strip()
        continue
      value_list.append(line)
      continue
    try:
      key, value = line.split('=')
    except:
      printerr('Error: ['+line+'] does not contain =')
      exit()
    # if the key is 'prompt', the value is multiline
    if key == 'prompt':
      inprompt = True;
      value_list = []
      continue
    params[key] = value.strip()

# assign each parameter to a global variable
engine      = params['engine']
temperature = float(params['temperature'])
top_p       = float(params['top_p'])
tokens      = float(params['tokens'])
freq_pen    = float(params['freq_pen'])
pres_pen    = float(params['pres_pen'])
AI_NAME     = params['AI_NAME']
USER_NAME   = params['USER_NAME']
prompt      = params['prompt'].replace('<<AI_NAME>>', AI_NAME, -1).replace('<<USER_NAME>>', USER_NAME, -1)
Prompt      = prompt
stop        = [ AI_NAME+':', USER_NAME+':' ]

conversation= []
text_block  = ''

# GPT-3 Completion function
def gpt3_completion(prompt, engine='text-davinci-003', temperature=0.7, top_p=1.0, tokens=400, freq_pen=0.0, pres_pen=0.0, stop=['HAL:', 'BIKSU:']):
    prompt = prompt.encode(encoding='ASCII',errors='ignore').decode()
    sx = len(prompt)
    tokens = max(16, int(4096 - (sx/3.5) - 100))
    try:
      response = openai.Completion.create(
        engine=engine,
        prompt=prompt,
        temperature=temperature,
        max_tokens=tokens,
        top_p=top_p,
        frequency_penalty=freq_pen,
        presence_penalty=pres_pen,
        stop=stop,
        timeout=90)
    except:
      printerr('GPT-3 experienced an error: '+str(e))
      return ''
    text = response['choices'][0]['text'].strip()
    return text

def cmdhelp():
  printinfo('DéjàVu System Commands')
  cmds = [
    [ '!status',           'Show status of current environment.' ],
    [ '!temperature [f]',  'Display or Set Temperature.', 'Valid value for f is 0.0 - 1.0' ],
    [ '!list [range]',     'List current conversation.', 'If range omitted, lists entire conversation.'],
    [ '!delete range',     'Delete conversation items.' ],
    [ '!prompt',           'Display current pre-conversation information.' ],
    [ '!summarize [what]', 'Where what can be prompt, conv, or all', 'Default is all.' ],
    [ '!save [file]',      'Save current conversation. If file is not specified', 'then saves to current conversation file.' ],
    [ '!exec [cmd...]',    'Execute a shell command.' ],
    [ '!exit',             'Exit DéjàVu.' ]
  ]
  for cmd in cmds:
    printinfo(format('%18s: %s' % (cmd[0], cmd[1])))
    cmd=cmd[2:]
    for cd in cmd:
      printinfo(format('%18s  %s' % ('', cd)))

# Print current parameters
def cmdstatus(all=False):
  printinfo('DéjàVu GPT-3 Terminal vs '+ Version +' |  Enter ! for help.')
  def pp(pref, suff):
    printinfo(format('%13s %s' % (pref+':', '{}'.format(suff))))
  pp(   'Conv. File',  os.path.basename(ConvFile))
  if all: 
    pp( 'History File',os.path.basename(historyFile))
    pp( 'AI Engine',   engine)
    pp( 'Tokens Used', int(len(prompt)/3.5))
    pp( 'Tokens Left', (max(16,int(4096-(len(prompt)/3.5)-100))))
    pp( 'Temperature', temperature)
    pp( 'Frequency',   freq_pen)
    pp( 'Presence',    pres_pen)
  pp(   'Your Name:',  USER_NAME)
  pp(   'AI Name:',    AI_NAME)


# Replace <<>> markers in prompt and conversation 
# with the appropriate text
def PromptReplace(conversationText, AIs='<<AI_NAME>>', AIr=AI_NAME, USs='<<USER_NAME>>', USr=USER_NAME):
  newp = Prompt
  newp = newp.replace('<<BLOCK>>', conversationText)
  newp = newp.replace(AIs, AIr, -1)
  newp = newp.replace(USs, USr, -1)
  return newp.strip() + '\n'

# Exit script nicely
def orderly_exit():
  print()
  if Verbose: printinfo('Exiting '+ScriptName+' '+ConvFile)
  sys.exit()

if __name__ == '__main__':
  if Verbose: cmdstatus()
  conversation = list()
  while True:
    Columns = shutil.get_terminal_size().columns - 1
    printstd(USER_NAME+':', color=Fore.YELLOW+Style.BRIGHT)
    if len(cmdTypeAhead): 
      userInput = cmdTypeAhead.pop(0)
      print(userInput)
    else:
      try: 
        userInput = input()
      except KeyboardInterrupt: orderly_exit()
    
    if userInput.strip() == '': continue

    # Process commands
    if userInput[0] == '!':
      cmd = userInput[1:].strip()
      tok = cmd.split()
      # help
      if(len(tok) == 0):
        cmdhelp(); continue
      elif tok[0] == 'help' or tok[0] == '?':
        cmdhelp(); continue

      # exec
      elif tok[0] == 'exec':
        try: subprocess.run(' '.join(tok[1:]), shell=True, executable='/bin/bash')
        except: printerr('#!#')
        continue

      # status
      elif tok[0] == 'stat' or tok[0] == 'status':
        cmdstatus(True); continue

      # temperature
      elif tok[0] == 'temp' or tok[0] == 'temperature':
        if len(tok) > 1:
          if is_numeric(tok[1]):
            sx = float(tok[1])
            temperature = max(0.0, min(1.0, sx))
        printinfo('Temperature is now '+str(temperature))
        continue

      # list [0-0]
      elif tok[0] == 'list':
        rnge = '0-99999' if len(tok) < 2 else tok[1]
        try:
          if '-' in rnge:
            start, end = rnge.split('-')
            start = 1 if start == '' else start
            end = 99999 if end == '' else end
            start = int(start); end = int(end)
          else:
            start = int(rnge); end = int(start)
        except ValueError:
          printerr('Invalid value in range ' + rnge)
          continue
        start = max(int(start), 1)
        end = min(int(end), len(conversation))
        i = int(start)
        printinfo('List Conversation')
        while i <= end:
          text = conversation[i-1]
          if text[0:len(USER_NAME)+2] == USER_NAME+': ':
            printstd(str(i)+'. '+USER_NAME+':', color=Fore.YELLOW, style=Style.DIM)
            text = text[len(USER_NAME)+2:]
          elif text[0:len(AI_NAME)+2] == AI_NAME+': ':
            printstd(str(i)+'. '+AI_NAME+':', color=Fore.GREEN, style=Style.DIM)
            text = text[len(AI_NAME)+2:] +'\n\n'
          for line in text.splitlines(): 
            printinfo(textwrap.fill(line, width=Columns), prefix='')
          i += 1
        continue

      # delete [0-0]
      elif tok[0] == 'dele' or tok[0] == 'delete':
        if len(tok) < 2: continue
        rnge = int_list(tok[1], 1, len(conversation), True)
        if not rnge: 
          printerr('Invalid range ' + tok[1])
          continue
        i = int(0)
        for r in rnge:
          del conversation[r-1]
          i += 1
        printinfo(str(i) +' entries deleted')
        continue

      # prompt display
      elif tok[0] == 'prom' or tok[0] == 'prompt':
        printinfo(PromptReplace(''), prefix='')
        continue

      # summarise
      elif tok[0] == 'summ' or tok[0] == 'summarize' or tok[0] == 'summarise':
        if len(tok) < 2: what = 'conv'
        else: what = tok[1]
        if what[0:6] == 'prompt':
          userInput = PromptReplace('') \
              +'\n\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        elif what[0:4] == 'conv':
          userInput = text_block \
              +'\n\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        elif what == 'all':
          userInput = PromptReplace(text_block) \
              +'\n\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        else:
          printerr('Invalid option. Valid options for summarize are prompt|conv|all.')
          continue

      # save [file]
      elif tok[0] == 'save':
        if len(tok) < 2: filename = ConvFile
        else: 
          filename = tok[1].replace('"', '').replace('"', '')
        if not '.dejavu.txt' in filename:
          filename += '.dejavu.txt'
        if not '/' in filename:
          filename = UserHome + '/' + filename
        if os.path.exists(filename):
          try:
            userInput = input('\n"'+filename+'" exists. Overwrite? (y/n) ')
            if userInput != 'y': continue
          except KeyboardInterrupt: continue
        p = 'engine='+engine+'\ntemperature='+str(temperature)+'\ntop_p='+str(top_p)+'\ntokens=4096'+'\nfreq_pen='+str(freq_pen)+'\npres_pen='+str(pres_pen)+'\nAI_NAME='+AI_NAME+'\nUSER_NAME='+USER_NAME+'\n'
        try:
          file_put_contents(filename, 
            p+'prompt=\n' \
             + PromptReplace('\n\n'.join(conversation),AI_NAME,'<<AI_NAME>>',USER_NAME,'<<USER_NAME>>') \
             + '\n\n<<BLOCK>>\n\nendprompt\n')
        except: 
          printerr('Error writing to ' + filename)
          continue
        printinfo('Session saved to ' + filename)  
        continue

      # import file
      elif tok[0] == 'impo' or tok[0] == 'import':
        #cmdstatus()
        if len(tok) < 2: 
          printerr('Text file to import must be specified.')
          continue
        filename = tok[1]
        if not os.path.exists(filename):
          printerr(filename+' does not exist.')
          continue
        printinfo('Importing from text file '+filename)  
        userInput = file_get_contents(filename).strip()+'\n'

      # exit
      elif tok[0] == 'exit':
        orderly_exit()

      # invalid command
      else:
        printerr('Invalid command: !' + cmd)
        cmdhelp(); continue

    # Prepend username to user input 
    conversation.append(USER_NAME+': %s' % userInput)
    # Aggregate the entire conversation 
    text_block = '\n'.join(conversation)
    prompt = PromptReplace(text_block) + '\n' + AI_NAME +': '

    # Send the entire conversation to GPT-3
    try:
      response = gpt3_completion(prompt, engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
    except:
      printerr('GPT-3 experienced an error. Possibly overloaded.')
      conversation.pop()
      continue

    # Print the response from GPT-3
    printstd(AI_NAME+':', color=Fore.GREEN)
    for line in response.splitlines(): 
      print(textwrap.fill(line, width=Columns))

    # Add the response to the conversation
    conversation.append(AI_NAME+': %s' % response)

    #for devaju -x -c 'cmd'
    if len(cmdTypeAhead)==0 and cmdExit: 
      exit()
#end
