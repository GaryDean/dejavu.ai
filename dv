#!/usr/bin/python3
# DéjàVu GPT-3 Terminal
# Linux terminal interface for GPT-3
# Gary Dean garydean@okusi.id
# https://github.com/GaryDean/dejavu.ai.git
#import atexit
import datetime
#import json
import openai
import os
import re
import readline
import shutil
import subprocess
import sys
import textwrap
#import time
import markdown
from colorama import init, Fore, Back, Style
init()

ScriptName  = os.path.realpath(sys.argv.pop(0)) 
ScriptDir   = os.path.dirname(ScriptName)
ScriptName  = os.path.basename(ScriptName)
sys.path.append(ScriptDir)
from dejavu_std import *

HomeDir     = os.path.expanduser('~')
UserHome    = HomeDir+'/.'+ScriptName 
os.makedirs(UserHome, exist_ok=True)
UserSysName = os.getenv('USER')
if UserSysName == '': UserSysName = os.getenv('USER_NAME')

REPOSITORY  = 'https://github.com/GaryDean/dejavu.ai.git'

# Process command line and define ConvFile to use
Version = readfile(ScriptDir+'/dejavu.version').strip()

ConvFile = ''
cmdTypeAhead = []
argvTypeAhead = []
Instructions = []
cmdEcho = True
AutoSave = False
cmdExit = 0
Verbose = True

# read .dv file
def read_dvfile(file):
  global cmdTypeAhead, argvTypeAhead, Instructions, Verbose
  cmdTypeAhead = []; Instructions = []
  if not '.dv' in file: file += '.dv'
  if not os.path.exists(file):
    if not '/' in file: file = UserHome + '/' + file
    if not os.path.exists(file):
      printerr('File \''+file+'\' does not exist.')
      return False
  lne = readfile(file)
  Lines = lne.split('\n')
  lne   = ''
  while len(Lines) > 0:
    line = Lines.pop(0).rstrip()
    if not line: 
      Instructions.append(''); continue
    if line[0] == '#': 
      Instructions.append(line); continue
    # handle \ line continuations
    while line[-1] == '\\' and len(Lines) > 0: 
      line = line[0:-1] + Lines.pop(0).rstrip()
    lne = line.rstrip('\r\n')
    if not lne: lne=''; continue
    if lne[0] == '!':
      tok = lne.split()
      if tok[0] == '!prompt' and len(tok) > 1:
        if tok[1] != '"""': 
          Instructions.append('!prompt '+' '.join(tok[1:]))
          lne = ''
          continue
        prompt = ''
        while len(Lines) > 0:
          line = Lines.pop(0).rstrip()
          if line == '"""':
            Instructions.append('!prompt '+prompt)
            break
          prompt += line + '\\n'
      elif tok[0] == '!instruction' and len(tok) > 1:
        if tok[1] != '"""': 
          Instructions.append('!instruction '+' '.join(tok[1:]))
          lne = ''
          continue
        instr = ''
        while len(Lines) > 0:
          line = Lines.pop(0).rstrip()
          if line == '"""':
            Instructions.append('!instruction '+instr)
            break
          instr += line + '\\n'
      else:
        Instructions.append(' '.join(tok))
      lne = ''
      continue
    Instructions.append('!instruction '+lne)
    lne = ''
  # end loop processing  
  lne = lne.rstrip('\r\n')
  if lne: Instructions.append('!instruction '+lne)
  cmdTypeAhead = Instructions.copy()
  cmdTypeAhead = [x for x in cmdTypeAhead if not x.startswith('#') and x]
  cmdTypeAhead.insert(0, '!echo off')
  if Verbose: 
    cmdTypeAhead.append('!status short')
    cmdTypeAhead.append('!echo on')
#  writefile('debug.dv', '\n'.join(cmdTypeAhead), 'w')
#  writefile('debug.dv', '\n---\n', 'a')
#  writefile('debug.dv', '\n'.join(Instructions), 'a')
  if len(argvTypeAhead):
    for lne in argvTypeAhead: cmdTypeAhead.append(lne)
    argvTypeAhead = []
  return True

# argv processing -------------------------
while len(sys.argv) > 0:
  arg = sys.argv.pop(0).strip()
  if not arg: continue
  if arg in ['-u', '--upgrade', '--update']:
    tempdir = dvtempname('upgrade', '')
    os.mkdir(tempdir); os.chdir(tempdir)
    qqq = "-{0}".format('v' if Verbose else 'q')
    subprocess.call(['git', 'clone', qqq, REPOSITORY, tempdir])
    cmd = tempdir + '/' + ScriptName + '.install'
    args = [ cmd, qqq ]
    os.execvp(cmd, args)
    exit()
  elif arg in ['-V', '--version']:
    print(ScriptName+' vs '+Version); exit()
  elif arg in ['-v', '--verbose']:
    Verbose = 1; cmdEcho = 1
  elif arg in ['-q', '--quiet']:
    Verbose = 0; cmdEcho = 0
  elif arg in ['-l', '--list']:
    for file in os.listdir(UserHome):
      if file.endswith('.'+ScriptName+'.txt'):
        filesize = os.stat(UserHome+'/'+file).st_size
        modified_date = datetime.datetime.fromtimestamp(os.stat(UserHome+'/'+file).st_mtime)
        print('{:12s} {:7.2f}KB {:20s}'.format(file[:-(5+len(ScriptName))], filesize/1024, modified_date.strftime('%Y-%m-%d %H:%M:%S')))
    exit()

  elif arg in ['-c', '--cmd']:
    if len(sys.argv) > 0:
      tmp = sys.argv.pop(0).strip()
      if tmp[0] == '\\': tmp = tmp[1:]
      argvTypeAhead.append(tmp)
    else:
      printerr('Command was not specified for', arg)
      exit()

  elif arg in ['-f', '--cmd-file']:
    if len(sys.argv) == 0:
      printerr('Command File was not specified for', arg)
      exit()
    ConvFile =sys.argv.pop(0)

  elif arg in ['-a', '--autosave']:
      AutoSave = 1

  elif arg in ['-x', '--exit']:
      Verbose = 0
      cmdExit = 1

  elif arg in ['-C', '--no-color']:
#    useColor = False
    useColor = printUseColor(False)

  elif arg in ['-h', '-?', '--help']:
    subprocess.run(['less', ScriptDir+'/'+ScriptName+'-synopsis.txt'])
    exit()
  # de-aggregate aggregated short options
  elif re.match(r'^-[caCfvqVh]', arg):
      sys.argv = [''] + ['-%s' % c for c in arg[1:]] + sys.argv
  elif re.match(r'^--', arg):
      printerr('Invalid option '+ arg); exit()
  elif arg[0:1] == '-':
      printerr('Invalid option '+ arg); exit()
  else:
    ConvFile = arg

# Conversation file validation and default
if len(ConvFile) == 0: 
  ConvFile = UserHome+'/default.dv'
  # Create default conversation file if not exist
  # and copy sample .dv files 
  if not os.path.exists(ConvFile):
    subprocess.run('rsync -aq ' + ScriptDir + '/*.dv ' + UserHome + '/', shell=True)
    string = readfile(ConvFile)
    string = re.sub(r'\n!USER_NAME \S+', '\n!USER_NAME '+UserSysName.upper(), string)
    writefile(ConvFile, string)
    subprocess.run('rsync -aq --exclude default.dv ' + ScriptDir + '/*.dv ' + UserHome + '/', shell=True)

if not ConvFile.endswith('.dv'): ConvFile += '.dv'
if not os.path.exists(ConvFile):
  if os.path.exists(UserHome+'/'+ConvFile):
    ConvFile = UserHome+'/'+ConvFile
  else:
    printerr('DéjàVu conversation file "' + ConvFile + '" does not exist!')
    exit()
ConvFile = os.path.realpath(ConvFile)
ConvFileName = os.path.basename(ConvFile)

# Get the openai API key
try:  openai.api_key = os.environ['OPENAI_API_KEY']
except KeyError:
  printerr('Environment variable OPENAI_API_KEY is not defined '+str(KeyError))
  printinfo([ 
    'Go to https://openai.com/api for your own API key.',
    ':~$ export OPENAI_API_KEY="your_key"',
    'If you set up your openai account as an organization, you will also have to set OPENAI_ORGANIZATION_ID',
    ':~$ export OPENAI_ORGANIZATION_ID="your_organization"',
    'Both these environment variables should be set in your ~/.bashrc file.' ])
  exit()

try:  openai.organization = os.environ['OPENAI_ORGANIZATION_ID']
except: openai.organization = ''

engine      = 'text-davinci-003'
temperature = 1
top_p       = 1
tokens      = 4096
freq_pen    = 0.0
pres_pen    = 0.0
AI_NAME     = 'HAL-2021'
USER_NAME   = 'DAVE'
#prompt      = params['prompt'].replace('<<AI_NAME>>', AI_NAME, -1).replace('<<USER_NAME>>', USER_NAME, -1)
prompt      = ''
Prompt      = prompt
stop        = ''

if not read_dvfile(ConvFile):
  printerr('Error reading '+ConvFile)
  exit()
historyFile = initHistory(ConvFile)


conversation= []
text_block  = ''

# GPT-3 Completion function
def gpt3_completion(prompt, engine='text-davinci-003', temperature=0.7, top_p=1.0, tokens=400, freq_pen=0.0, pres_pen=0.0, stop=['HAL:', 'BIKSU:']):
    prompt = prompt.encode(encoding='ASCII',errors='ignore').decode()
    sx = len(prompt)
    tokens = max(16, int(4096 - (sx/3.5) - 100))
    try:
      response = openai.Completion.create(
        engine=engine,
        prompt=prompt,
        temperature=temperature,
        max_tokens=tokens,
        top_p=top_p,
        frequency_penalty=freq_pen,
        presence_penalty=pres_pen,
        stop=stop,
        timeout=90)
    except:
      printerr('GPT-3 experienced an error: '+str(e))
      return ''
    text = response['choices'][0]['text'].strip()
    return text

def cmdhelp():
  printinfo('DéjàVu System Commands')
  cmds = [
    [ '!status',            'Show status of current environment.' ],
    [ '!temperature [f]',   'Display or Set Temperature.', 'Valid value for "f" is 0.0 - 1.0.' ],
    [ '!list [long|short] [range]',     \
                            '', 'List current conversation.', \
                            '"short" for condenced list, "long" for full list.', \
                            'Default is "long".', \
                            'If "range" omitted, lists entire conversation.'],
    [ '!delete range',      'Delete conversation items in "range".' ],
    [ '!clear',             'Clear all conversation. Same as !delete 1-' ],
    [ '!files',             'Display conversation scripts in current and user home', 
                            'directories, with option to edit.' ],
    [ '!edit',              'Edit the current conversation prompt.dv file.' ],
    [ '!prompt [prompt]',   'Display current conversation set-up information.', 'If "prompt" is specified, set the new conversion prompt.' ],
    [ '!tldr [range]',      'Summarize all conversation responses in "range".', \
                            'Default is the previous response.' ],
    [ '!summarize [conversation|prompt|all]',  '', \
                            'Summarise every conversation or prompt items.', \
                            'Default is "conversation".' ],
    [ '!save [file]',       'Save current conversation. If "file" is not specified', \
                            'then saves to current conversation file.' ],
    [ '!import [file]',     'Import "file" into the input prompt.' ],
    [ '!exec [cmd...]',     'Execute a shell command.' ],
    [ '!echo [on|off]',     'Turn command echo on|off.'],
    [ '!help',              'Open DéjàVu Help file.' ],
    [ '!exit',              'Exit DéjàVu.' ]
  ]
  for cmd in cmds:
    printinfo(format('%16s: %s' % (cmd[0], cmd[1])))
    for cd in cmd[2:]: printinfo(format('%16s  %s' % ('', cd)))
  printinfo('Note: All commands can be shortened to first four letters,',
            'eg, !temp for !temperature')
  printinfo('"range" can be in these forms "1,2,3", "4-6", "7-", "-8", "all"', \
            'and can be combined in any order.')

# Print current parameters
def cmdstatus(all=False):
  printinfo('DéjàVu GPT-3 Terminal vs '+ Version +' |  Enter ! for help.')
  def pp(pref, suff):
    printinfo(format('%13s %s' % (pref+':', '{}'.format(suff))))
  pp(   'Your Name',   USER_NAME)
  pp(   'AI Name',     AI_NAME)
  pp(   'Conversation',ConvFile.replace(UserHome,'~')) # os.path.basename(ConvFile))
  if all: 
    pp( 'History File',historyFile.replace(UserHome,'~')) # os.path.basename(historyFile))
    pp( 'AI Engine',   engine)
    pp( 'Tokens Used', int(len(prompt)/3.5))
    pp( 'Tokens Left', (max(16,int(4096-(len(prompt)/3.5)-100))))
    pp( 'Temperature', temperature)
    pp( 'Frequency',   freq_pen)
    pp( 'Presence',    pres_pen)
    pp( 'Cmd Echo',    'On' if cmdEcho else 'Off')
    pp( 'Editor',      os.path.basename(EDITOR))
    pp( 'Browser',     os.path.basename(BROWSER))


# Replace <<>> markers in prompt and conversation 
# with the appropriate text
def PromptReplace(conversationText, AIs='<<AI_NAME>>', AIr='', USs='<<USER_NAME>>', USr=''):
  global Prompt, AI_NAME, USER_NAME
  if not AIr: AIr = AI_NAME
  if not USr: USr = USER_NAME
  newp = Prompt+('\n' if Prompt[-1]!='\n' else '')+conversationText
  newp = newp.replace('<<CONVERSATION>>', '')
  newp = newp.replace(AIs, AIr, -1)
  newp = newp.replace(USs, USr, -1)
  return newp.strip() + '\n'

def autoSave(filename):
  global conversation, Instructions
  printinfo('AutoSaving '+filename, end='')
#  file = '/tmp/'+ScriptName+'-autosave-'+str(datetime.datetime.now().time()).replace(':','_')+'.dv'
  file = dvtempname('autosave', '.dv')
  try:
    writefile(file, '', 'w')
    for tmp in Instructions:
      if tmp[0:8] == '!prompt ':
        tmp = '!prompt """\n' + \
              tmp[8:].replace('\\n', '\n') 
        writefile(file, tmp, 'a')
        writefile(file, '"""\n', 'a')
        continue
      elif tmp[0:13] == '!instruction ':
        tmp = '!instruction """\n' + \
              tmp[13:].replace('\\n', '\n') + '\n' + \
              '"""'
      # ignore !conversation in Instructions
      elif tmp[0:14] == '!conversation ':
        continue

      writefile(file, tmp+'\n', 'a')

    for tmp in conversation:
        writefile(file, '!conversation ' +tmp.replace('\n','\\n')+'\n', 'a')

    if os.path.exists(filename): os.replace(filename, filename+'~')
    os.rename(file, filename)
  except:
    printerr('Error renaming '+file+' to '+filename)

# Exit script nicely
def orderly_exit():
  global AutoSave
  if AutoSave: autoSave(ConvFile)
  print(Style.RESET_ALL if useColor else '')
  if Verbose: printinfo('Exiting '+ScriptName+' '+ConvFile)
  sys.exit()

#---------------------------------------------------------------------------------
if __name__ == '__main__':
  conversation = list()
  while True:
    if len(cmdTypeAhead)==0 and cmdExit: sys.exit()
    Columns = shutil.get_terminal_size().columns - 1
    if len(cmdTypeAhead): 
      userInput = cmdTypeAhead.pop(0)
      if userInput[0].rstrip() == '#' or userInput.strip() == '': continue
      if cmdEcho and userInput[0:5] != '!echo': 
        printstd(USER_NAME+':', color=Fore.YELLOW+Style.BRIGHT)
        print(userInput)
    else:
      cmdEcho = True
      printstd(USER_NAME+':', color=Fore.YELLOW+Style.BRIGHT)
      try: userInput = input().lstrip()
      except KeyboardInterrupt: orderly_exit()
    
    if userInput.strip() == '' or userInput[0].rstrip() == '#': continue

    # Process commands
    if userInput[0] == '!':
      cmd = userInput[1:].strip()
      tok = cmd.split()

      # help
      if(len(tok) == 0): cmdhelp(); continue

      tok[0] = tok[0].lower()

      # README.md
      if tok[0] == 'help' or tok[0] == '?' or tok[0] == '!':
        tmp = dvtempname('README', '.html')
        writefile(tmp, markdown.markdown(readfile(ScriptDir+'/README.md')))
        subprocess.run([BROWSER, tmp])
        os.remove(tmp)
        continue

      elif tok[0] == 'echo':
        if len(tok) > 1:
          tok[1] = tok[1].lower()
          if tok[1] == '1' or tok[1] == 'on' or tok[1] == 'true':
            cmdEcho = True
          elif tok[1] == '0' or tok[1] == 'off' or tok[1] == 'false':
            cmdEcho = False
        else: printinfo('Command Echo is '+str('On' if cmdEcho else 'Off'))
        continue

      elif tok[0] == 'auto' or tok[0] == 'autosave':
        if len(tok) > 1:
          tok[1] = tok[1].lower()
          if tok[1] == '1' or tok[1] == 'on' or tok[1] == 'true':
            AutoSave = True
          elif tok[1] == '0' or tok[1] == 'off' or tok[1] == 'false':
            AutoSave = False
        else: printinfo('AutoSave is '+str('On' if AutoSave else 'Off'))
        continue

      # files
      elif tok[0] == 'file' or tok[0] == 'files':
        tmp = selectFile(['.', UserHome], '**/*.dv', 'Select File to Edit: ', UserHome)
        if tmp:
          modify_datestamp = os.path.getmtime(tmp)
          try: subprocess.run(EDITOR +' '+ tmp, shell=True, executable='/bin/bash')
          except: printerr('ERROR in editor'); continue
          if modify_datestamp != os.path.getmtime(tmp):
            if input('Run '+tmp+'? y/n ') != 'y': continue
            readline.write_history_file(historyFile)
            read_dvfile(ConvFile)
            historyFile = initHistory(ConvFile)
        continue

      # edit
      elif tok[0] == 'edit':
        modify_datestamp = os.path.getmtime(ConvFile)
        try: subprocess.run(EDITOR +' '+ ConvFile, shell=True, executable='/bin/bash')
        except: printerr('#!#'); continue
        if modify_datestamp != os.path.getmtime(ConvFile):
          if input('Re-Load '+ConvFile+'? y/n ') == 'y':
            readline.write_history_file(historyFile)
            read_dvfile(ConvFile)
            historyFile = initHistory(ConvFile)
        continue

      # run
      elif tok[0] == 'run':
        if len(tok) < 2:
          file = selectFile(['.', UserHome], '**/*.dv', 'Select File to Run: ', UserHome)
          if not file: continue
        else: 
          file = ' '.join(tok[1:])
          if not os.path.exists(file):
            printerr('!run: File '+file+' does not exist.')
            continue
        try:
          readline.write_history_file(historyFile)
          read_dvfile(file)
          ConvFile = file
          historyFile = initHistory(ConvFile)
        except:
          read_dvfile(ConvFile)
          historyFile = initHistory(ConvFile)
        continue

      # exec
      elif tok[0] == 'exec':
        try: subprocess.run(' '.join(tok[1:]), shell=True, executable='/bin/bash')
        except: printerr('#!#')
        continue

      # status
      elif tok[0] == 'stat' or tok[0] == 'status':
        longstatus = True
        if len(tok) > 1: 
          if tok[1] == 'short': longstatus = False
        cmdstatus(longstatus)
        continue

      # username
      elif tok[0] == 'user' or tok[0] == 'user_name':
        if len(tok) > 1: 
          tmp = re.sub(r'[^a-zA-Z0-9_-]', '', '-'.join(tok[1:])).strip().upper()
          if len(tmp) < 4 or len(tmp) > 16:
            printerr('Invalid length in user_name "'+tmp+'". Min 4, Max 16.')
            continue
          USER_NAME = tmp
        elif cmdEcho: printinfo('USER_NAME is now '+USER_NAME)
        continue
      # ai_name
      elif tok[0] == 'ai_n' or tok[0] == 'ai_name':
        if len(tok) > 1: 
          tmp = re.sub(r'[^a-zA-Z0-9_-]', '', '-'.join(tok[1:])).strip().upper()
          if len(tmp) < 4 or len(tmp) > 16:
            printerr('Invalid length in ai_name "'+tmp+'". Min 4, Max 16.')
            continue
          AI_NAME = tmp
        elif cmdEcho: printinfo('AI_NAME is now '+AI_NAME)
        continue
      #engine=text-davinci-003
      elif tok[0] == 'engi' or tok[0] == 'engine':
        if len(tok) > 1:
          engine = tok[1] 
        elif cmdEcho: printinfo('Engine is now '+engine)
        continue
      # temperature
      elif tok[0] == 'temp' or tok[0] == 'temperature':
        if len(tok) > 1 and is_num(tok[1]):
          temperature = max(0.0, min(1.0, float(tok[1])))
        elif cmdEcho: printinfo('Temperature is now '+str(temperature))
        continue
      #top_p=1.0
      elif tok[0] == 'top_' or tok[0] == 'top_p':
        if len(tok) > 1 and is_num(tok[1]):
          top_p = max(0.0, min(1.0, float(tok[1])))
        elif cmdEcho: printinfo('Top_p is now '+str(top_p))
        continue
      #tokens=4096
      elif tok[0] == 'toke' or tok[0] == 'tokens':
        if len(tok) > 1 and is_num(tok[1]):
          tokens = max(16, min(4096, int(tok[1])))
        elif cmdEcho: printinfo('Tokens is now '+str(tokens))
        continue
      #freq_pen=0.0
      elif tok[0] == 'freq' or tok[0] == 'freq_pen':
        if len(tok) > 1 and is_num(tok[1]):
          freq_pen = max(-2, min(2, float(tok[1])))
        elif cmdEcho: printinfo('Freq_pen is now '+str(freq_pen))
        continue
      #pres_pen=0.0
      elif tok[0] == 'pres' or tok[0] == 'pres_pen':
        if len(tok) > 1 and is_num(tok[1]):
          pres_pen = max(-2, min(2, float(tok[1])))
        elif cmdEcho: printinfo('Pres_pen is now '+str(pres_pen))
        continue

      # prompt [newprompt]
      elif tok[0] == 'prom' or tok[0] == 'prompt':
        if len(tok) > 1:
          Prompt = ' '.join(tok[1:]).replace('\\n', '\n').strip()
        elif cmdEcho: printinfo(Prompt, prefix='')
        continue

      # instruction [instruction]
      elif tok[0] == 'inst' or tok[0] == 'instruction':
        if len(tok) > 1:
          userInput = ' '.join(tok[1:]).replace('\\n', '\n').strip()
        else: 
          for tmp in Instructions:
            if tmp[0:8] == '!prompt ':
              tmp = '!prompt """\n' + \
                    tmp[8:].replace('\\n', '\n') + \
                    '"""'
            elif tmp[0:13] == '!instruction ':
              tmp = '!instruction """\n' + \
                    tmp[13:].replace('\\n', '\n') + '\n' + \
                    '"""'
            printinfo(tmp, prefix='')
          continue
        # proceed to gpt

      # conversation [conversation]
      elif tok[0] == 'conv' or tok[0] == 'conversation':
        if len(tok) > 1:
          conversation.append(' '.join(tok[1:]).replace('\\n', '\n'))
        else: 
          for tmp in conversation:
            printinfo(tmp, prefix='')
        continue

      # list [0-0]
      elif tok[0] == 'list':
        short = False
        if len(tok) > 1:
          if   tok[1][0:4] == 'shor': short = True; tok.pop(1)
          elif tok[1][0:4] == 'long': short = False; tok.pop(1)
        if len(tok) < 2: tok.append('all')
        rnge = int_list(','.join(tok[1:]), 1, len(conversation), False)
        if not rnge: printerr('Invalid range !list ' + tok[1]); continue
        i = int(0)
        for r in rnge:
          text = conversation[r-1].replace('<<USER_NAME>>', USER_NAME).replace('<<AI_NAME>>', AI_NAME)
          if text[0:len(USER_NAME)+2] == USER_NAME+': ':
            printstd(str(i+1)+'. '+USER_NAME+':', color=Fore.YELLOW, style=Style.DIM)
            text = text[len(USER_NAME)+2:]
          elif text[0:len(AI_NAME)+2] == AI_NAME+': ':
            printstd(str(i+1)+'. '+AI_NAME+':', color=Fore.GREEN, style=Style.DIM)
            text = text[len(AI_NAME)+2:] +'\n\n'
          for line in text.splitlines(): 
            if short: printinfo(line[0:Columns-3]+'...',prefix=''); break
            else: printinfo(textwrap.fill(line, width=Columns), prefix='')
          i += 1
        continue

      # clear
      elif tok[0] == 'clea' or tok[0] == 'clear':
        conversation = []
        continue

      # delete [0-0]
      elif tok[0] == 'dele' or tok[0] == 'delete':
        if len(tok) < 2: continue
        rnge = int_list(tok[1], 1, len(conversation), True)
        if not rnge: printerr('Invalid range !delete ' + tok[1]); continue
        i = int(0)
        for r in rnge:
          del conversation[r-1]
          i += 1
        if cmdEcho: printinfo(str(i) +' entries deleted')
        continue

      # summarise
      elif tok[0] == 'summ' or tok[0] == 'summarize' or tok[0] == 'summarise':
        if len(tok) < 2: what = 'conversation'
        else: what = tok[1]
        if what[0:4] == 'prom' or what == 'prompt':
          userInput = PromptReplace('') \
              +'\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        elif what[0:4] == 'conv' or what == 'conversation':
          userInput = text_block \
              +'\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        elif what == 'all':
          userInput = PromptReplace(text_block) \
              +'\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        else:
          printerr('Invalid option. Valid options for !summarize are prompt|conv|all.')
          continue

      # tldr [range]
      elif tok[0] == 'tldr' or tok[0] == 'tl;dr':
        if len(tok) < 2: tok.append(str(len(conversation)))
        rnge = int_list(tok[1], 1, len(conversation), False)
        if not rnge: printerr('Invalid range !tldr ' + tok[1]); continue
        i=0
        for r in rnge:
          text = conversation[r-1]
          if text[0:13] != '<<AI_NAME>>: ': continue
          text = text.replace('<<AI_NAME>>', AI_NAME).replace('<<USER_NAME>>', USER_NAME)
          try:
            response = gpt3_completion(text+'\n\nTL;DR: ', engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
          except: 
            printerr('GPT-3 experienced an error. Possibly overloaded.')
            break
          printstd(AI_NAME+' TL;DR'+ ('' if len(rnge)==1 else '['+str(i+1)+']') + ':', color=Fore.GREEN)
          printinfo(response, prefix='')
          conversation.append('<<AI_NAME>>: %s' % response)
          i+=1
        continue

      # save [file]
      elif tok[0] == 'save':
        if len(tok) < 2: filename = ConvFile
        else: filename = tok[1].replace('"', '').replace('"', '')
        if not '.dv' in filename: filename += '.dv'
        if not '/' in filename: filename = UserHome + '/' + filename
        if os.path.exists(filename):
          try:  
            userInput = input('\n"'+filename+'" exists. Overwrite? (y/n) ')
            if userInput != 'y': continue
          except KeyboardInterrupt: continue
        p = 'engine='+engine+'\ntemperature='+str(temperature)+'\ntop_p='+str(top_p)+'\ntokens=4096'+'\nfreq_pen='+str(freq_pen)+'\npres_pen='+str(pres_pen)+'\nAI_NAME='+AI_NAME+'\nUSER_NAME='+USER_NAME+'\n'
        try:
          writefile(filename, 
            p+'prompt=\n' \
             + PromptReplace('\n'.join(conversation),AI_NAME,'<<AI_NAME>>',USER_NAME,'<<USER_NAME>>').strip() \
             + '\n')
        except: 
          printerr('Error writing to ' + filename)
          continue
        if cmdEcho: printinfo('Session saved to ' + filename)  
        continue

      # import file
      elif tok[0] == 'impo' or tok[0] == 'import':
        #cmdstatus()
        if len(tok) < 2: 
          tmpfile = dvtempname('command', '')
          writefile(tmpfile, '')
          try: subprocess.run(EDITOR +' '+ tmpfile, shell=True, executable='/bin/bash')
          except: printerr('#!#'); continue
          userInput = readfile(tmpfile)
          os.remove(tmpfile)
          if not userInput: continue
          if input('Execute command in '+tmpfile+'? y/n ') != 'y':
              continue
        else:
          filename = tok[1]
          if not os.path.exists(filename):
            printerr(filename+' does not exist.')
            continue
          if cmdEcho: printinfo('Importing from text file '+filename)  
          userInput = readfile(filename).strip()+'\n'

      # exit
      elif tok[0] == 'exit':
        orderly_exit()
        continue

      # invalid command
      else:
        printerr('Invalid command: !' + cmd)
        cmdhelp()
        continue

    # Prepend username to user input 
    conversation.append('<<USER_NAME>>: %s' % userInput)
    # Aggregate the entire conversation 
    text_block = ('\n'.join(conversation)).strip()
    writefile('debug', '\n---\n'+PromptReplace(text_block, '<<AI_NAME>>', AI_NAME, '<<USER_NAME>>', USER_NAME), 'a')
    # Send the entire conversation to GPT-3
    try:
      response = gpt3_completion(PromptReplace(text_block)+'\n'+AI_NAME+': ', \
            engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
    except:
      printerr('GPT-3 experienced an error. Possibly overloaded.')
      conversation.pop()
      continue
    # Add the response to the conversation list
    conversation.append('<<AI_NAME>>: %s' % response)
    # Print the response from GPT-3
    printstd(AI_NAME+':', color=Fore.GREEN)
    for line in response.splitlines(): 
      print(textwrap.fill(line, width=Columns))

    # eg, devaju -x -c 'command'
    if len(cmdTypeAhead)==0 and cmdExit: sys.exit()
#end
