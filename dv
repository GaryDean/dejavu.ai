#!/usr/bin/python3
"""
DéjàVu GPT-3 Terminal Interface for GPT-3
Gary Dean garydean@okusi.id
https://github.com/GaryDean/dejavu.ai.git

#: git clone https://github.com/GaryDean/dejavu.ai.git /tmp/dejavu \
    && /tmp/dejavu/dv.install
"""
# pylint: disable=global-statement
# pylint: disable=too-many-arguments
# pylint: disable=wildcard-import
# pylint: disable=line-too-long
# pylint: disable=multiple-statements
# pylint: disable=invalid-name
# pylint: disable=broad-exception-caught
# pylint: disable=wrong-import-position

import os
import datetime
import re
import readline
import subprocess
import sys
import textwrap
import openai
from colorama import Fore, Style

ScriptName  = os.path.realpath(sys.argv.pop(0))
ScriptDir   = os.path.dirname(ScriptName)
ScriptName  = os.path.basename(ScriptName)
sys.path.append(ScriptDir)
from dejavu_std import *

dvHome = f'{HOME}/.{ScriptName}'
os.makedirs(dvHome, exist_ok=True)

REPOSITORY = 'https://github.com/GaryDean/dejavu.ai.git'

# Process command line and define ConvFile to use
Version = readfile(f'{ScriptDir}/dejavu.version').strip()

ConvFile      = ''
cmdTypeAhead  = []
argvTypeAhead = []
Instructions  = []
cmdEcho       = True
AutoSave      = False
cmdExit       = 0
Verbose       = True

def read_dvfile(dvfile):
  """  Read .dv script  """
  global cmdTypeAhead, argvTypeAhead, Instructions
  cmdTypeAhead = []; Instructions = []
  if not '.dv' in dvfile: dvfile += '.dv'
  if not os.path.exists(dvfile):
    if not '/' in dvfile: dvfile = f'{dvHome}/{dvfile}'
    if not os.path.exists(dvfile):
      printerr(f'File "{dvfile}" does not exist.')
      return False
  lne = readfile(dvfile)
  Lines = lne.split('\n')
  lne   = ''
  while len(Lines) > 0:
    line = Lines.pop(0).rstrip()
    if not line:
      Instructions.append(''); continue
    if line[0] == '#':
      Instructions.append(line); continue
    # handle \ line continuations
    while line[-1] == '\\' and len(Lines) > 0:
      line = line[0:-1] + Lines.pop(0).rstrip()
    lne = line.rstrip('\r\n')
    if not lne: lne=''; continue
    if lne[0] == '!':
      tok = lne.split()
      if tok[0] == '!prompt' and len(tok) > 1:
        if tok[1] != '"""':
          Instructions.append('!prompt '+' '.join(tok[1:]))
          lne = ''
          continue
        prompt = ''
        while len(Lines) > 0:
          line = Lines.pop(0).rstrip()
          if line == '"""':
            Instructions.append('!prompt '+prompt)
            break
          prompt += line + '\\n'
      elif tok[0] == '!instruction' and len(tok) > 1:
        if tok[1] != '"""':
          Instructions.append('!instruction '+' '.join(tok[1:]))
          lne = ''
          continue
        instr = ''
        while len(Lines) > 0:
          line = Lines.pop(0).rstrip()
          if line == '"""':
            Instructions.append('!instruction '+instr)
            break
          instr += line + '\\n'
      else:
        Instructions.append(' '.join(tok))
      lne = ''
      continue
    Instructions.append('!instruction '+lne)
    lne = ''
  # end loop processing
  lne = lne.rstrip('\r\n')
  if lne: Instructions.append('!instruction '+lne)
  cmdTypeAhead = Instructions.copy()
  cmdTypeAhead = [x for x in cmdTypeAhead if not x.startswith('#') and x]
  cmdTypeAhead.insert(0, '!echo off')
  if Verbose:
    cmdTypeAhead.append('!status short')
    cmdTypeAhead.append('!echo on')
  if len(argvTypeAhead) > 0:
    for lne in argvTypeAhead: cmdTypeAhead.append(lne)
    argvTypeAhead = []
  return True

def dvUsage():
  """ dv short invocation help """
  print('DéjàVu - GPT-3 Terminal and Chatbot vs '+Version)
  print("Usage: "+ScriptName+""" [-vqlfxuV] [-c cmd] [dvfile]
Where 'dvfile' is a conversation.dv file. Default '~/.dv/default.dv'
 -l|--list      List dvfiles in '~/.dv/'.
 -a|--autosave on|off
                On exit, save conversation to current dvfile. Default is off.
 -c|--cmd 'cmd' Execute 'cmd' on entry to DéjàVu.
 -x|--exit      Immediately exit DéjàVu after first command has been executed.
 -v|--verbose   Verbose on. Default is on.
 -q|--quiet     Verbose off.
 -V|--version   Print DéjàVu version.
 -C|--no-color  Do not use color. Default is to use color.
 -u|--upgrade   Upgrade DéjàVu from git repository.
 --help         Full Help manpages.
""")

# argv processing -------------------------
while len(sys.argv) > 0:
  arg = sys.argv.pop(0).strip()
  if not arg: continue
  if arg in ['-u', '--upgrade', '--update']:
    tempdir = tempname('upgrade', '')
    os.makedirs(tempdir, exist_ok=True); os.chdir(tempdir)
    #qqq = "-{0}".format('v' if Verbose else 'q')
    qqq = '-v' if Verbose else '-q'
    subprocess.call(['git', 'clone', qqq, REPOSITORY, tempdir])
    cmd = f'{tempdir}/{ScriptName}.install'
    args = [ cmd, qqq, '-a' if qqq == '-q' else '' ]
    os.execvp(cmd, args)
    sys.exit()
  elif arg in ['-V', '--version']:
    print(f'{ScriptName} vs {Version}'); sys.exit()
  elif arg in ['-v', '--verbose']:
    Verbose = 1; cmdEcho = 1
  elif arg in ['-q', '--quiet']:
    Verbose = 0; cmdEcho = 0

  elif arg in ['-l', '--list']:
    printinfo(f'Dejavu conversation files in {dvHome}')
    for file in os.listdir(dvHome):
      if file.endswith('.dv'):
        filesize = os.stat(f'{dvHome}/{file}').st_size/1024
        modified_date = datetime.datetime.fromtimestamp(os.stat(dvHome+'/'+file).st_mtime).strftime('%Y-%m-%d %H:%M:%S')
        printstd(f'{file:12s} {filesize:7.2f}KB {modified_date:20s}')
    sys.exit()

  elif arg in ['-c', '--cmd']:
    if len(sys.argv) > 0:
      tmp = sys.argv.pop(0).strip()
      if tmp[0] == '\\': tmp = tmp[1:]
      argvTypeAhead.append(tmp)
    else:
      printerr('Command was not specified for', arg)
      sys.exit()

  elif arg in ['-a', '--autosave']:
    AutoSave = 1

  elif arg in ['-x', '--exit']:
    Verbose = 0
    cmdExit = 1

  elif arg in ['-C', '--no-color']:
    UseColor(False)

  elif arg in ['-h', '-?']:
    dvUsage(); sys.exit()
  elif arg =='--help':
    os.execvp('man', ['man', ScriptName]); sys.exit()

  # de-aggregate aggregated short options
  elif re.match(r'^-[caCfvqVhuxl]', arg):
    sys.argv = [''] + [f'-{c}' for c in arg[1:]] + sys.argv
  elif re.match(r'^--', arg):
    printerr('Invalid option '+ arg); sys.exit()
  elif arg[0:1] == '-':
    printerr('Invalid option '+ arg); sys.exit()
  else:
    ConvFile = arg


# Conversation file validation and default
if len(ConvFile) == 0:
  ConvFile = dvHome+'/default.dv'
  # Create default conversation file if not exist
  # and copy sample .dv files
  if not os.path.exists(ConvFile):
    subprocess.run(f'rsync -aq {ScriptDir}/*.dv {dvHome}/', shell=True, check=False)
    string = readfile(ConvFile)
    string = re.sub(r'\n!USER_NAME \S+', '\n!USER_NAME '+USER.upper(), string)
    writefile(ConvFile, string)
    subprocess.run('rsync -aq --exclude default.dv ' + ScriptDir + '/*.dv ' \
      + dvHome + '/', shell=True, check=False)
if not ConvFile.endswith('.dv'): ConvFile += '.dv'
if not os.path.exists(ConvFile):
  if os.path.exists(f'{dvHome}/{ConvFile}'):
    ConvFile = f'{dvHome}/{ConvFile}'
  else:
    try:
      ConvFile = os.path.realpath(ConvFile)
      writefile(ConvFile, readfile(dvHome+'/default.dv'))
    except Exception as e:
      printerr('DéjàVu file "' + ConvFile + '" could not be created!', str(e))
      sys.exit()
ConvFile = os.path.realpath(ConvFile)
ConvFileName = os.path.basename(ConvFile)

def getOpenAIKeys():
  """ # Get OpenAI API keys """
  try:
    openai.api_key = os.environ['OPENAI_API_KEY']
  except KeyError:
    printerr('Environment variable OPENAI_API_KEY is not defined '+str(KeyError))
    printinfo([
      'Go to https://openai.com/api for your own API key.',
      ':~$ export OPENAI_API_KEY="your_key"',
      'If you set up your openai account as an organization, '
      ' you will also have to set OPENAI_ORGANIZATION_ID',
      ':~$ export OPENAI_ORGANIZATION_ID="your_organization"',
      'Both these environment variables should be set in your ~/.bashrc file.' ])
    sys.exit()
  try:  openai.organization = os.environ['OPENAI_ORGANIZATION_ID']
  except KeyError: openai.organization = ''
getOpenAIKeys()

engine      = 'text-davinci-003'
temperature = 1
top_p       = 1
tokens      = 4096
freq_pen    = 0.0
pres_pen    = 0.0
AI_NAME     = 'HAL-2021'
USER_NAME   = 'DAVE'
prompt      = ''
Prompt      = prompt
stop        = ''

if not read_dvfile(ConvFile):
  printerr('Error reading '+ConvFile)
  sys.exit()
historyFile = initHistory(ConvFile)

conversation = []
text_block  = ''

def gpt3_completion(prompt, engine, temperature, top_p, tokens, freq_pen, pres_pen, stop):
  """  GPT-3 Completion function """
  prompt = prompt.encode(encoding='ASCII',errors='ignore').decode()
  sx = len(prompt)
  tokens = max(16, int(4096 - (sx/3.5) - 100))
  try:
    response = openai.Completion.create(
      engine=engine,
      prompt=prompt,
      temperature=temperature,
      max_tokens=tokens,
      top_p=top_p,
      frequency_penalty=freq_pen,
      presence_penalty=pres_pen,
      stop=stop,
      timeout=90)
  except Exception as e:
    printerr('GPT-3 experienced an error: '+str(e))
    return ''
  text = response['choices'][0]['text'].strip()
  return text

def cmdhelp():
  """ dejavu command help """
  printinfo('DéjàVu System Commands', '')
  printinfo('Note: All commands can be shortened to first four letters,',
            'eg, !temp for !temperature', '',
            '"range" can be in the forms "1,2,3", "4-6", "7-", "-8", "all"',
            'and can be combined in any order.', '',
            "For more comprehensive help, enter '!help'", '')
  cmds = [
    ['!status',         'Show status of current environment.'],
    ['!temperature [f]','Display or Set Temperature.',
                        'Valid value for "f" is 0.0 - 1.0.'],
    ['!list [long|short] [range]', '',
                        'List current conversation.',
                        '"short" for condenced list, "long" for full list.',
                        'Default is "long".',
                        'If "range" omitted, lists entire conversation.'],
    ['!delete range',   'Delete conversation items in "range".'],
    ['!clear',          'Clear all conversation.  Same as !delete 1-'],
    ['!files',          'Display conversation scripts in current and user home',
                        'directories, with option to edit.'],
    ['!edit',           'Edit the current conversation prompt.dv file.'],
    ['!prompt [prompt]','Display current conversation set-up information.',
                        'If "prompt" is specified, set the new conversion prompt.'],
    ['!tldr [range]',   'Summarize all conversation responses in "range".',
                        'Default is the previous response.'],
    ['!summarize [conversation|prompt|all]', '',
                        'Summarise every conversation or prompt items.',
                        'Default is "conversation".'],
    ['!save [file]',    'Save current conversation.  If "file" is not specified',
                        'then saves to current conversation file.'],
    ['!import [file]',  'Import "file" into the input prompt.',
                        'If "file" is not specified, opens EDITOR to enable ',
                        'multi-line commands.'],
    ['!exec [cmd...]',  'Execute a shell command.'],
    ['!echo [on|off]',  'Turn command echo on|off.'],
    ['!help',           'Open DéjàVu Help file.'],
    ['!exit|!quit',     'Exit DéjàVu.  Pressing ^C will also exit.']
  ]
  for cmd in cmds:
    printinfo(f'{cmd[0]:16s}: {cmd[1]}')
    for cd in cmd[2:]: printinfo(f'%16s  {cd}' % '')

def cmdstatus(showall=False):
  """ Print current parameters """
  #global Prompt, conversation
  printinfo('DéjàVu GPT-3 Terminal vs '+ Version +' |  Enter ! for help.')
  def pp(pref, suff):
    printinfo(f'%13s: {suff}' % pref)
  pp(   'Your Name',   USER_NAME)
  pp(   'AI Name',     AI_NAME)
  pp(   'Conversation',ConvFile.replace(HOME,'~'))
  if showall:
    pp( 'History File',historyFile.replace(HOME,'~'))
    pp( 'AI Engine',   engine)
    sx = len(Prompt)+len(''.join(conversation))
    pp( 'Tokens Used', int(sx/3.5))
    pp( 'Tokens Left', (max(16,int(4096-(sx/3.5)-100))))
    pp( 'Temperature', temperature)
    pp( 'Frequency',   freq_pen)
    pp( 'Presence',    pres_pen)
    pp( 'Cmd Echo',    'On' if cmdEcho else 'Off')
    pp( 'Shell',       os.path.basename(SHELL))
    pp( 'Editor',      os.path.basename(EDITOR))
    pp( 'Browser',     os.path.basename(BROWSER))


def PromptReplace(conversationText, AIs='<<AI_NAME>>', AIr='', USs='<<USER_NAME>>', USr=''):
  """
  Replace <<>> markers in prompt and conversation
  with the appropriate text
  """
  #global Prompt, AI_NAME, USER_NAME
  if not AIr: AIr = AI_NAME
  if not USr: USr = USER_NAME
  newp = Prompt+('\n' if Prompt[-1]!='\n' else '') + conversationText
  newp = newp.replace(AIs, AIr, -1)
  newp = newp.replace(USs, USr, -1)
  return newp.strip() + '\n'

def autoSave(filename):
  """ Autosave current chat """
  #global conversation, Instructions
  printinfo('AutoSaving '+filename, end='')
  file = tempname('autosave', '.dv')
  try:
    writefile(file, '', 'w')
    for tmp in Instructions:
      if tmp[0:8] == '!prompt ':
        tmp = '!prompt """\n' + \
              tmp[8:].replace('\\n', '\n')
        writefile(file, tmp, 'a')
        writefile(file, '"""\n', 'a')
        continue
      # ignore !conversation in Instructions
      if tmp[0:14] == '!conversation ':
        continue
      if tmp[0:13] == '!instruction ':
        tmp = '!instruction """\n' + \
              tmp[13:].replace('\\n', '\n') + '\n' + \
              '"""'
      writefile(file, tmp+'\n', 'a')

    for tmp in conversation:
      writefile(file, '!conversation ' +tmp.replace('\n','\\n')+'\n', 'a')

    if os.path.exists(filename): os.replace(filename, filename+'~')
    os.rename(file, filename)
  except Exception as e:
    printerr('Error renaming '+file+' to '+filename, str(e))

def orderly_exit():
  """ Exit script nicely """
  #global AutoSave
  if AutoSave: autoSave(ConvFile)
  print(Style.RESET_ALL if UseColor() else '')
  if Verbose: printinfo(f'Exiting {ScriptName} {ConvFile}')
  sys.exit()

#---------------------------------------------------------------------------------
if __name__ == '__main__':
  conversation = []
  while True:
    if len(cmdTypeAhead)==0 and cmdExit: sys.exit()
    getScreenColumns()
    if len(cmdTypeAhead) > 0:
      userInput = cmdTypeAhead.pop(0)
      if userInput[0].rstrip() == '#' or userInput.strip() == '': continue
      if cmdEcho and userInput[0:5] != '!echo':
        printstd(USER_NAME+':', color=Fore.YELLOW+Style.BRIGHT)
        print(userInput)
    else:
      cmdEcho = True
      printstd(str(len(conversation)+1)+'. '+USER_NAME+':', color=Fore.YELLOW+Style.BRIGHT)
      try:
        userInput = input().lstrip()
      except KeyboardInterrupt:
        orderly_exit()

    if userInput.strip() == '' or userInput[0].rstrip() == '#': continue

    # Process commands
    if userInput[0] == '!':
      cmd = userInput[1:].strip()
      tok = cmd.split()

      # help
      if len(tok) == 0: cmdhelp(); continue

      tok[0] = tok[0].lower()

      # man page - README.md
      if tok[0] == 'help' or tok[0] == '?' or tok[0] == '!':
        subprocess.run(['man', 'dv'], check=False)
        continue

      # exit
      if tok[0] == 'exit' or tok[0] == 'quit':
        orderly_exit()
        continue

      if tok[0] == 'echo':
        if len(tok) > 1:
          tok[1] = tok[1].lower()
          if tok[1] == '1' or tok[1] == 'on' or tok[1] == 'true':
            cmdEcho = True
          elif tok[1] == '0' or tok[1] == 'off' or tok[1] == 'false':
            cmdEcho = False
        else: printinfo('Command Echo is '+str('On' if cmdEcho else 'Off'))
        continue

      if tok[0] == 'auto' or tok[0] == 'autosave':
        if len(tok) > 1:
          tok[1] = tok[1].lower()
          if tok[1] == '1' or tok[1] == 'on' or tok[1] == 'true':
            AutoSave = True
          elif tok[1] == '0' or tok[1] == 'off' or tok[1] == 'false':
            AutoSave = False
        else: printinfo('AutoSave is '+str('On' if AutoSave else 'Off'))
        continue

      # files
      if tok[0] == 'file' or tok[0] == 'files':
        tmp = selectFile(['.', dvHome], '**/*.dv', 'Select File to Edit: ', dvHome)
        if tmp:
          modify_datestamp = os.path.getmtime(tmp)
          try:
            subprocess.run(EDITOR +' '+ tmp, shell=True, executable=SHELL, check=False)
          except Exception as e:
            printerr('ERROR in editor.', str(e)); continue
          if modify_datestamp != os.path.getmtime(tmp):
            if input('Run '+tmp+'? y/n ') != 'y': continue
            readline.write_history_file(historyFile)
            read_dvfile(ConvFile)
            historyFile = initHistory(ConvFile)
        continue

      # edit
      if tok[0] == 'edit':
        modify_datestamp = os.path.getmtime(ConvFile)
        try:
          subprocess.run(EDITOR +' '+ ConvFile, shell=True, executable=SHELL, check=False)
        except Exception as e:
          printerr('Edit error '+str(e)); continue
        if modify_datestamp != os.path.getmtime(ConvFile):
          if input('Re-Load '+ConvFile+'? y/n ') == 'y':
            readline.write_history_file(historyFile)
            read_dvfile(ConvFile)
            historyFile = initHistory(ConvFile)
        continue

      # run
      if tok[0] == 'run':
        if len(tok) < 2:
          file = selectFile(['.', dvHome], '**/*.dv', 'Select File to Run: ', dvHome)
          if not file: continue
        else:
          file = ' '.join(tok[1:])
          if not os.path.exists(file):
            printerr('!run: File '+file+' does not exist.')
            continue
        try:
          readline.write_history_file(historyFile)
          read_dvfile(file)
          ConvFile = file
          historyFile = initHistory(ConvFile)
        except Exception:
          read_dvfile(ConvFile)
          historyFile = initHistory(ConvFile)
        continue

      # exec
      if tok[0] == 'exec':
        try:
          subprocess.run(' '.join(tok[1:]), shell=True, executable=SHELL, check=False)
        except Exception as e:
          printerr('Exec error '+str(e))
        continue

      # status
      if tok[0] == 'stat' or tok[0] == 'status':
        longstatus = True
        if len(tok) > 1:
          if tok[1] == 'short': longstatus = False
        cmdstatus(longstatus)
        continue

      # username
      if tok[0] == 'user' or tok[0] == 'user_name':
        if len(tok) > 1:
          tmp = re.sub(r'[^a-zA-Z0-9_-]', '', '-'.join(tok[1:])).strip().upper()
          if len(tmp) < 4 or len(tmp) > 16:
            printerr('Invalid length in user_name "'+tmp+'". Min 4, Max 16.')
            continue
          USER_NAME = tmp
        elif cmdEcho: printinfo('USER_NAME is now '+USER_NAME)
        continue
      # ai_name
      if tok[0] == 'ai_n' or tok[0] == 'ai_name':
        if len(tok) > 1:
          tmp = re.sub(r'[^a-zA-Z0-9_-]', '', '-'.join(tok[1:])).strip().upper()
          if len(tmp) < 4 or len(tmp) > 16:
            printerr('Invalid length in ai_name "'+tmp+'". Min 4, Max 16.')
            continue
          AI_NAME = tmp
        elif cmdEcho: printinfo('AI_NAME is now '+AI_NAME)
        continue
      #engine=text-davinci-003
      if tok[0] == 'engi' or tok[0] == 'engine':
        if len(tok) > 1:
          engine = tok[1]
        elif cmdEcho: printinfo('Engine is now '+engine)
        continue
      # temperature
      if tok[0] == 'temp' or tok[0] == 'temperature':
        if len(tok) > 1 and is_num(tok[1]):
          temperature = max(0.0, min(1.0, float(tok[1])))
        elif cmdEcho: printinfo('Temperature is now '+str(temperature))
        continue
      #top_p=1.0
      if tok[0] == 'top_' or tok[0] == 'top_p':
        if len(tok) > 1 and is_num(tok[1]):
          top_p = max(0.0, min(1.0, float(tok[1])))
        elif cmdEcho: printinfo('Top_p is now '+str(top_p))
        continue
      #tokens=4096
      if tok[0] == 'toke' or tok[0] == 'tokens':
        if len(tok) > 1 and is_num(tok[1]):
          tokens = max(16, min(4096, int(tok[1])))
        elif cmdEcho: printinfo('Tokens is now '+str(tokens))
        continue
      #freq_pen=0.0
      if tok[0] == 'freq' or tok[0] == 'freq_pen':
        if len(tok) > 1 and is_num(tok[1]):
          freq_pen = max(-2, min(2, float(tok[1])))
        elif cmdEcho: printinfo('Freq_pen is now '+str(freq_pen))
        continue
      #pres_pen=0.0
      if tok[0] == 'pres' or tok[0] == 'pres_pen':
        if len(tok) > 1 and is_num(tok[1]):
          pres_pen = max(-2, min(2, float(tok[1])))
        elif cmdEcho: printinfo('Pres_pen is now '+str(pres_pen))
        continue

      # prompt [newprompt]
      if tok[0] == 'prom' or tok[0] == 'prompt':
        if len(tok) > 1:
          Prompt = ' '.join(tok[1:]).replace('\\n', '\n').strip()
        elif cmdEcho: printinfo(Prompt, prefix='')
        continue

      # conversation [conversation]
      if tok[0] == 'conv' or tok[0] == 'conversation':
        if len(tok) > 1:
          conversation.append(' '.join(tok[1:]).replace('\\n', '\n'))
        else:
          for tmp in conversation:
            printinfo(tmp, prefix='')
        continue

      # list [0-0]
      if tok[0] == 'list':
        short = False
        if len(tok) > 1:
          if   tok[1][0:4] == 'shor': short = True; tok.pop(1)
          elif tok[1][0:4] == 'long': short = False; tok.pop(1)
        if len(tok) < 2: tok.append('all')
        rnge = int_list(','.join(tok[1:]), 1, len(conversation), False)
        if not rnge: printerr('Invalid range !list ' + tok[1]); continue
        i = int(0)
        for r in rnge:
          text = conversation[r-1].replace('<<USER_NAME>>', USER_NAME).replace('<<AI_NAME>>', AI_NAME)
          if text[0:len(USER_NAME)+2] == USER_NAME+': ':
            printstd(str(i+1)+'. '+USER_NAME+':', color=Fore.YELLOW, style=Style.DIM)
            text = text[len(USER_NAME)+2:]
          elif text[0:len(AI_NAME)+2] == AI_NAME+': ':
            printstd(str(i+1)+'. '+AI_NAME+':', color=Fore.GREEN, style=Style.DIM)
            text = text[len(AI_NAME)+2:] +'\n\n'
          for line in text.splitlines():
            if short:
              printinfo(line[0:ScreenColumns-3]+'...',prefix='')
              break
            printinfo(textwrap.fill(line, width=ScreenColumns), prefix='')
          i += 1
        continue

      # clear
      if tok[0] == 'clea' or tok[0] == 'clear':
        conversation = []
        continue

      # delete [0-0]
      if tok[0] == 'dele' or tok[0] == 'delete':
        if len(tok) < 2: continue
        rnge = int_list(tok[1], 1, len(conversation), True)
        if not rnge: printerr('Invalid range !delete ' + tok[1]); continue
        i = int(0)
        for r in rnge:
          del conversation[r-1]
          i += 1
        if cmdEcho: printinfo(str(i) +' entries deleted')
        continue

      # tldr [range]
      if tok[0] == 'tldr' or tok[0] == 'tl;dr':
        if len(tok) < 2: tok.append(str(len(conversation)))
        rnge = int_list(tok[1], 1, len(conversation), False)
        if not rnge: printerr('Invalid range !tldr ' + tok[1]); continue
        i=0
        for r in rnge:
          text = conversation[r-1]
          if text[0:13] != '<<AI_NAME>>: ': continue
          text = text.replace('<<AI_NAME>>', AI_NAME).replace('<<USER_NAME>>', USER_NAME)
          try:
            response = gpt3_completion(text+'\n\nTL;DR: ', engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
          except Exception as e:
            printerr('GPT-3 experienced an error. Possibly overloaded.', str(e))
            break
          printstd(AI_NAME+' TL;DR'+ ('' if len(rnge)==1 else '['+str(i+1)+']') + ':', color=Fore.GREEN)
          printinfo(response, prefix='')
          conversation.append(f'<<AI_NAME>>: {response}')
          i+=1
        continue

      # save [file]
      if tok[0] == 'save':
        if len(tok) < 2: filename = ConvFile
        else: filename = tok[1].replace('"', '').replace('"', '')
        if not '.dv' in filename: filename += '.dv'
        if not '/' in filename: filename = f'{dvHome}/{filename}'
        if os.path.exists(filename):
          try:
            userInput = input(f'\n{filename} exists. Overwrite? (y/n) ')
            if userInput != 'y': continue
          except KeyboardInterrupt: continue
        p = 'engine='+engine+'\ntemperature='+str(temperature)+'\ntop_p='+str(top_p)+'\ntokens=4096'+'\nfreq_pen='+str(freq_pen)+'\npres_pen='+str(pres_pen)+'\nAI_NAME='+AI_NAME+'\nUSER_NAME='+USER_NAME+'\n'
        try:
          writefile(filename,
            p+'prompt=\n' \
             + PromptReplace('\n'.join(conversation),AI_NAME,'<<AI_NAME>>',USER_NAME,'<<USER_NAME>>').strip() \
             + '\n')
        except Exception as e:
          printerr('Error writing to ' + filename, str(e))
          continue
        if cmdEcho: printinfo('Session saved to ' + filename)
        continue

      if tok[0] == 'vars' or tok[0] == 'locals':
        varsearch = tok[1] if len(tok) > 1 else ''
        locals_list = [(key, value) for key, value in locals().items() if not callable(value)]
        for key, value in locals_list:
          value = str(value).replace('\n','\\n')
          if value[0:7] == '<module': continue
          if varsearch and key[0:len(varsearch)] != varsearch: continue
          print(f"{key}={value}")
        print()
        print('Environment:')
        for env in ['USER', 'HOME', 'SHELL', 'EDITOR', 'BROWSER', 'TMPDIR', 'PATH', 'OPENAI_API_KEY', 'OPENAI_ORGANIZATION_ID']:
          print(f'{env}={str(os.getenv(env))}')
        continue

      # instruction [instruction]
      if tok[0] == 'inst' or tok[0] == 'instruction':
        if len(tok) > 1:
          userInput = ' '.join(tok[1:]).replace('\\n', '\n').strip()
        else:
          for tmp in Instructions:
            if tmp[0:8] == '!prompt ':
              tmp = '!prompt """\n' + \
                    tmp[8:].replace('\\n', '\n') + \
                    '"""'
            elif tmp[0:13] == '!instruction ':
              tmp = '!instruction """\n' + \
                    tmp[13:].replace('\\n', '\n') + '\n' + \
                    '"""'
            printinfo(tmp, prefix='')
          continue
        # proceed to gpt

      # import file
      elif tok[0] == 'impo' or tok[0] == 'import':
        if len(tok) < 2:
          tmpfile = tempname('command', '.dv')
          writefile(tmpfile, '')
          while True:
            try:
              subprocess.run(f'{EDITOR} {tmpfile}', shell=True, executable=SHELL, check=False)
            except Exception as e:
              printerr('Import file error.', str(e))
              userInput = ''
              break
            userInput = readfile(tmpfile)
            if not userInput: break
            while True:
              ynr = input('Execute command in '+tmpfile+'? yes/no/re-edit ').lower()
              if ynr in ['y', 'n', 'r']: break
              printerr('Valid input y, n, or r.')
            if ynr == 'y': break
            if ynr == 'r': continue
            userInput = ''
            break
          try:
            os.remove(tmpfile)
            os.remove(tmpfile+'~')
          except FileNotFoundError: pass
          if not userInput: continue
          print('\n' + userInput.strip())
        # proceed to gpt

        else:
          filename = tok[1]
          if not os.path.exists(filename):
            printerr(filename+' does not exist.')
            continue
          if cmdEcho: printinfo('Importing from text file '+filename)
          userInput = readfile(filename).strip()+'\n'
        # proceed to gpt

      # summarise
      elif tok[0] == 'summ' or tok[0] == 'summarize' or tok[0] == 'summarise':
        if len(tok) < 2: what = 'conversation'
        else: what = tok[1]
        if what[0:4] == 'prom' or what == 'prompt':
          userInput = PromptReplace('') \
              +'\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        elif what[0:4] == 'conv' or what == 'conversation':
          userInput = text_block \
              +'\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        elif what == 'all':
          userInput = PromptReplace(text_block) \
              +'\n\n' + USER_NAME + ': Write a detailed summary of all the above: '
        else:
          printerr('Invalid option. Valid options for !summarize are prompt|conv|all.')
          continue
        # proceed to gpt

      # invalid command
      else:
        printerr('Invalid command: !' + cmd)
        if Verbose: printinfo("Enter '!' for command help")
        continue

    # Prepend username to user input
    conversation.append(f'<<USER_NAME>>: {userInput}')
    # Aggregate the entire conversation
    text_block = ('\n'.join(conversation)).strip()
    # Send the entire conversation to GPT-3
    try:
      response = gpt3_completion(PromptReplace(text_block)+'\n'+AI_NAME+': ', \
            engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
    except Exception as e:
      printerr('GPT-3 experienced an error. Possibly overloaded.', str(e))
      conversation.pop()
      continue
    # Add the response to the conversation list
    conversation.append(f'<<AI_NAME>>: {response}')
    # Print the response from GPT-3
    printstd(str(len(conversation)+1)+'. '+AI_NAME+':', color=Fore.GREEN)
    for line in response.splitlines():
      print(textwrap.fill(line, width=ScreenColumns))

    # eg, devaju -x -c 'command'
    if len(cmdTypeAhead)==0 and cmdExit: sys.exit()
#end
