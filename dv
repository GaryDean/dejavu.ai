#!/usr/bin/python3
"""
DéjàVu GPT-3 Terminal Interface for GPT-3
Gary Dean garydean@okusi.id
https://github.com/GaryDean/dejavu.ai.git

#: git clone https://github.com/GaryDean/dejavu.ai.git /tmp/dejavu \
    && /tmp/dejavu/dv.install
"""
# pylint: disable=global-statement
# pylint: disable=wildcard-import
# pylint: disable=line-too-long
# pylint: disable=wrong-import-position
# pylint: disable=invalid-name
# pylint: disable=broad-exception-caught
# pylint: disable=multiple-statements

import os
import datetime
import re
import readline
import subprocess
import sys
import textwrap
import openai
import tiktoken
from colorama import Fore, Style

ScriptName  = os.path.realpath(sys.argv.pop(0))
ScriptDir   = os.path.dirname(ScriptName)
ScriptName  = os.path.basename(ScriptName)
if not ScriptDir in sys.path: sys.path.append(ScriptDir)
from dejavu_std import *
from awesome_prompts import *

dvHome = f'{HOME}/.{ScriptName}'
os.makedirs(dvHome, exist_ok=True)
# Create dvHome dir contents if dvHome/default.dv does not exist.
if not os.path.exists(dvHome+'/default.dv'):
  printinfo(f'Welcome to DéjàVu, {USER.title()}.')
  if not copy_files_recursive(ScriptDir, dvHome, '*.dv', verbose=True):
    printerr('Default files copy error.')
    sys.exit()
  string = readfile(dvHome+'/default.dv')
  string = re.sub(r'\n!USER_NAME \S+', '\n!USER_NAME '+USER.upper(), string)
  string = re.sub(r'\n/USER_NAME \S+', '\n/USER_NAME '+USER.upper(), string)
  writefile(dvHome+'/default.dv', string)

REPOSITORY = 'https://github.com/GaryDean/dejavu.ai.git'
REPOSITORY_VERSION='https://raw.githubusercontent.com/GaryDean/dejavu.ai/master/dejavu.version?xyz=123'
UpdateCheck = False

# Process command line and define ConvFile to use
Version = readfile(f'{ScriptDir}/dejavu.version').strip()

def find_dv_file(dvfilename:str, **kwargs) -> str:
  """ 
  Finds/Creates fqfn for dv filename. 

  If not mustexist and file does not exist 
  then defaults to sys.path[0]+'/'+filename.ext 
  and creates file with contents of /usr/share/dejavu.ai/default.dv.

  Return '' if fail.
  """
  mustexist = kwargs.get('mustexist', True)
  searchpaths = kwargs.get('searchpaths', [ dvHome, './', HOME ])
  dvfilename = find_file(dvfilename, mustexist=mustexist, searchpaths=searchpaths, ext='.dv')
  if dvfilename == '':
    return ''
  if not os.path.exists(dvfilename):
    try:
      dvtext = readfile(ScriptDir + '/default.dv')
      dvtext = re.sub(r'\n!USER_NAME \S+', '\n!USER_NAME '+USER.upper(), dvtext)
      dvtext = re.sub(r'\n/USER_NAME \S+', '\n/USER_NAME '+USER.upper(), dvtext)
      writefile(dvfilename, dvtext)
    except:
      printerr('Could not create '+dvfilename)
      return ''
    printinfo('New dv file '+dvfilename+' created.')
  return dvfilename

ConvFile      = ''
cmdTypeAhead  = []
argvTypeAhead = []
Instructions  = []
cmdEcho       = True
AutoSave      = False
cmdExit       = 0
Verbose       = True

def read_dvfile(dvfile:str) -> bool:
  """  Read .dv script ------------------------------------------------------- """
  global cmdTypeAhead, argvTypeAhead, Instructions
  cmdTypeAhead = []; Instructions = []
  dvfile = find_dv_file(dvfile, mustexist=True, ext='.dv')
  if dvfile == '':
    printerr(f'File "{dvfile}" does not exist.')
    return False
  lne = readfile(dvfile)
  Lines = lne.split('\n')
  lne   = ''
  while len(Lines) > 0:
    line = Lines.pop(0).rstrip()
    if not line:
      Instructions.append(''); continue
    if line[0] == '#':
      Instructions.append(line); continue
    # handle \ line continuations
    while line[-1] == '\\' and len(Lines) > 0:
      line = line[0:-1] + Lines.pop(0).rstrip()
    lne = line.rstrip('\r\n')
    if not lne: lne=''; continue
    if lne[0] == '!' or lne[0] == '/':
      alne = lne.split()
      if (alne[0] == '/prompt' or alne[0] == '!prompt') and len(alne) > 1:
        if alne[1] != '"""':
          Instructions.append('/prompt '+' '.join(alne[1:]))
          lne = ''
          continue
        promptstr = ''
        while len(Lines) > 0:
          line = Lines.pop(0).rstrip()
          if line == '"""':
            Instructions.append('/prompt '+promptstr)
            break
          promptstr += line + '\\n'
      elif alne[0] == '/instruction' or alne[0] == '!instruction' and len(alne) > 1:
        if alne[1] != '"""':
          Instructions.append('/instruction '+' '.join(alne[1:]))
          lne = ''
          continue
        instr = ''
        while len(Lines) > 0:
          line = Lines.pop(0).rstrip()
          if line == '"""':
            Instructions.append('/instruction '+instr)
            break
          instr += line + '\\n'
      else:
        Instructions.append(' '.join(alne))
      lne = ''
      continue
    Instructions.append('/instruction '+lne)
    lne = ''
  # end loop processing
  lne = lne.rstrip('\r\n')
  if lne: Instructions.append('/instruction '+lne)
  cmdTypeAhead = Instructions.copy()
  cmdTypeAhead = [x for x in cmdTypeAhead if not x.startswith('#') and x]
  cmdTypeAhead.insert(0, '/echo off')
  if Verbose:
    cmdTypeAhead.append('/status short')
    cmdTypeAhead.append('/echo on')
  if len(argvTypeAhead) > 0:
    for lne in argvTypeAhead: cmdTypeAhead.append(lne)
    argvTypeAhead = []
  return True

def dvUsage():
  """ dv short invocation help ----------------------------------------------- """
  print('DéjàVu - GPT-3 Terminal and Chatbot vs '+Version)
  print("Usage: "+ScriptName+""" [-vqlfxuV] [-c cmd] [dvfile]
Where 'dvfile' is a conversation.dv file. Default '~/.dv/default.dv'
 -l|--list      List dvfiles in '~/.dv/'.
 -a|--autosave on|off
                On exit, save conversation to current dvfile. Default is off.
 -c|--cmd 'cmd' Execute 'cmd' on entry to DéjàVu.
 -x|--exit      Immediately exit DéjàVu after first command has been executed.
 -v|--verbose   Verbose on. Default is on.
 -q|--quiet     Verbose off.
 -V|--version   Print DéjàVu version.
 -C|--no-color  Do not use color. Default is to use color.
 -u|--upgrade   Upgrade DéjàVu from git repository.
 --help         Full Help manpages.
""")

# argv processing ---------------------------------------------------------------
while len(sys.argv) > 0:
  sysargv = sys.argv.pop(0).strip()
  if not sysargv: continue
  if sysargv in ['-u', '--upgrade', '--update']:
    tempdir_upgrade = tempname('upgrade', '')
    os.makedirs(tempdir_upgrade, exist_ok=True); os.chdir(tempdir_upgrade)
    #qqq = "-{0}".format('v' if Verbose else 'q')
    qqq = '-v' if Verbose else '-q'
    subprocess.call(['git', 'clone', qqq, REPOSITORY, tempdir_upgrade])
    installcmd = f'{tempdir_upgrade}/{ScriptName}.install'
    installargs = [ installcmd, qqq, '-a' if qqq == '-q' else '' ]
    os.execvp(installcmd, installargs)
    sys.exit()
  elif sysargv in ['-V', '--version']:
    print(f'{ScriptName} vs {Version}'); sys.exit()
  elif sysargv in ['-v', '--verbose']:
    Verbose = 1; cmdEcho = 1
  elif sysargv in ['-q', '--quiet']:
    Verbose = 0; cmdEcho = 0

  elif sysargv in ['-l', '--list']:
    printinfo(f'Dejavu conversation files in {dvHome}')
    for listfile in os.listdir(dvHome):
      if listfile.endswith('.dv'):
        filesize = os.stat(f'{dvHome}/{listfile}').st_size/1024
        modified_date = datetime.datetime.fromtimestamp(os.stat(dvHome+'/'+listfile).st_mtime).strftime('%Y-%m-%d %H:%M:%S')
        printstd(f'{listfile:12s} {filesize:7.2f}KB {modified_date:20s}')
    sys.exit()

  elif sysargv in ['-c', '--cmd']:
    if len(sys.argv) > 0:
      argvparam = sys.argv.pop(0).strip()
      if argvparam[0] == '\\': argvparam = argvparam[1:]
      argvTypeAhead.append(argvparam)
    else:
      printerr('Command was not specified for ' + sysargv)
      sys.exit()

  elif sysargv in ['-a', '--autosave']:
    AutoSave = 1

  elif sysargv in ['-x', '--exit']:
    Verbose = 0
    cmdExit = 1

  elif sysargv in ['-C', '--no-color']:
    UseColor(False)

  elif sysargv in ['-h', '-?']:
    dvUsage(); sys.exit()
  elif sysargv =='--help':
    os.execvp('man', ['man', ScriptName]); sys.exit()

  # de-aggregate aggregated short options
  elif re.match(r'^-[caCfvqVhuxl]', sysargv):
    sys.argv = [''] + [f'-{c}' for c in sysargv[1:]] + sys.argv
  elif re.match(r'^--', sysargv):
    printerr('Invalid option '+ sysargv); sys.exit()
  elif sysargv[0:1] == '-':
    printerr('Invalid option '+ sysargv); sys.exit()
  else:
    ConvFile = sysargv


# Conversation file validation and default --------------------------------------
if len(ConvFile) == 0:
  ConvFile = dvHome+'/default.dv'
try:
  ConvFile =  find_dv_file(ConvFile, mustexist=False)
  if ConvFile == '':
    printerr(f'DéjàVu file "{ConvFile}" could not be opened.')
    sys.exit()
except Exception as e:
  printerr(f'DéjàVu file "{ConvFile}" could not be created.', str(e))
  sys.exit()
ConvFileName = os.path.basename(ConvFile)

def getOpenAIKeys():
  """ # Get OpenAI API keys -------------------------------------------------- """
  try:
    openai.api_key = os.environ['OPENAI_API_KEY']
  except KeyError:
    printerr('Environment variable OPENAI_API_KEY is not defined.')
    printinfo('Go to https://openai.com/api for your own API key.',
      '  $ export OPENAI_API_KEY="your_key"',
      'If you set up your openai account as an organization, you will',
      'also have to set OPENAI_ORGANIZATION_ID:',
      '  $ export OPENAI_ORGANIZATION_ID="your_organization"',
      'Both these environment variables should be set in your ~/.bashrc',
      'file or in /etc/bash.bashrc.')
    sys.exit()
  try:  openai.organization = os.environ['OPENAI_ORGANIZATION_ID']
  except KeyError: openai.organization = ''
getOpenAIKeys()

engine      = 'text-davinci-003'
temperature = 1
top_p       = 1
tokens      = 4096
freq_pen    = 0.0
pres_pen    = 0.0
AI_NAME     = 'HAL-2021'
USER_NAME   = 'DAVE'
prompt      = ''
Prompt      = prompt
stop        = ''

if not read_dvfile(ConvFile):
  printerr('Error reading '+ConvFile)
  sys.exit()
historyFile = initHistory(ConvFile)

conversation = []
text_block  = ''


def num_tokens_from_string(gptstring: str, encoding_name: str) -> int:
  """Returns the number of tokens in a text gpt string."""
  encoding = tiktoken.get_encoding(encoding_name)
  num_tokens = len(encoding.encode(gptstring))
  return num_tokens


def gpt3_completion(prompt:str, engine:str, temperature:float, top_p:float, tokens:int, freq_pen:float, pres_pen:float, stop:list) -> str:
  """  GPT-3 Completion function ---------------------------------------------- """
  used_tokens = num_tokens_from_string(prompt, 'gpt2')
  if Verbose and cmdEcho: printinfo(f'{used_tokens} tokens in prompt')
  prompt = prompt.encode(encoding='ASCII',errors='ignore').decode()
#  tokens = max(16, int(4096 - (len(prompt.replace(' ',''))/4) - 100))
  try:
    gpt3_response = openai.Completion.create(
      engine=engine,
      prompt=prompt,
      temperature=temperature,
      max_tokens=max(16, 4096 - used_tokens - 100),
      top_p=top_p,
      frequency_penalty=freq_pen,
      presence_penalty=pres_pen,
      stop=stop,
      timeout=90)
  except Exception as gpte:
    printerr('GPT-3 experienced an error: ' + str(gpte))
    return ''
  return gpt3_response['choices'][0]['text'].strip('\n')


def cmd_help():
  """ dejavu command help ----------------------------------------------------- """
  printinfo('DéjàVu System Commands', style=Style.BRIGHT)
  json_data = json.loads(readfile(ScriptDir+'/dejavu-command-help.json'))
  rowcount = 1
  for cmdhelp in json_data:
    if (rowcount + len(cmdhelp)) >= getScreenRows():
      rowcount = 0
      if has_color(sys.stdout):
        try:
          input(Style.RESET_ALL+'More...')
          print('\r\x1b[2K', end='')
        except KeyboardInterrupt:
          print(file=sys.stderr)
          break
    if len(cmdhelp) == 1:
      printinfo(cmdhelp[0], style=Style.BRIGHT)
      rowcount += 1
      continue
    printinfo(f' {cmdhelp[0]:17s} {cmdhelp[1]}')
    rowcount += 1
    for chelp in cmdhelp[2:]:
      printinfo(f' %17s {chelp}' % '')
      rowcount += 1


def cmdstatus(showall:bool=False):
  """ Print current parameters ----------------------------------------------- """
  #global Prompt, conversation
  global UpdateCheck
  printinfo('DéjàVu GPT-3 Terminal vs '+ Version +' |  Enter ! for help.')
  def pp(pref:str, suff:str):
    printinfo(f'%13s: {suff}' % pref)
  pp(   'Your Name',   USER_NAME)
  pp(   'AI Name',     AI_NAME)
  pp(   'Conversation',ConvFile.replace(HOME,'~'))
  pp(   'AutoSave',    'On' if AutoSave else 'Off')
  if showall:
    pp( 'History File',historyFile.replace(HOME,'~'))
    pp( 'AI Engine',   engine)
    sx = num_tokens_from_string(Prompt+''.join(conversation), 'gpt2')
    pp( 'Tokens Used', int(sx))
    pp( 'Tokens Left', int(4096-sx))
    pp( 'Temperature', temperature)
    pp( 'Frequency',   freq_pen)
    pp( 'Presence',    pres_pen)
    pp( 'Cmd Echo',    'On' if cmdEcho else 'Off')
    pp( 'Shell',       os.path.basename(SHELL))
    pp( 'Editor',      os.path.basename(EDITOR))
    pp( 'Browser',     os.path.basename(BROWSER))
  if not UpdateCheck:
    try:
      r = requests.get(REPOSITORY_VERSION, timeout=2, headers={'User-Agent': 'Wget/1.21.2', 'Accept': '*/*', 'Accept-Encoding': 'identity', 'Connection': 'Keep-Alive'})
      data = str(r.text).strip()
      if Version < data:
        pp('Update', f'Version {data} of DéjàVu is now available.')
        pp('', f"Run '{ScriptName} -q --update' to update.")
      UpdateCheck = True
    except:
      pass


def PromptReplace(conversationText:str, AIs:str='<<AI_NAME>>', AIr:str='', USs:str='<<USER_NAME>>', USr:str='') -> str:
  """ ---------------------------------------------------------------------------
  Replace <<>> markers in prompt and conversation
  with the appropriate text
  """
  #global Prompt, AI_NAME, USER_NAME
  if not AIr: AIr = AI_NAME
  if not USr: USr = USER_NAME
  newp = Prompt+('\n' if Prompt[-1]!='\n' else '') + conversationText
  newp = newp.replace(AIs, AIr, -1)
  newp = newp.replace(USs, USr, -1)
  return newp.strip() + '\n'


def autoSave(dv_filename:str):
  """ Autosave current chat -------------------------------------------------- """
  #global conversation, Instructions
  printinfo('AutoSaving '+dv_filename, end='')
  autosave_file = tempname('autosave', '.dv')
  try:
    writefile(autosave_file, '', 'w')
    for instr in Instructions:
      if instr[0:8] == '/prompt ' or instr[0:8] == '!prompt ':
        instr = '/prompt """\n' + \
              instr[8:].replace('\\n', '\n')
        writefile(autosave_file, instr, 'a')
        writefile(autosave_file, '"""\n', 'a')
        continue
      # ignore /conversation in Instructions
      if instr[0:14] == '/conversation ' or instr[0:14] == '!conversation ':
        continue
      if instr[0:13] == '/instruction ':
        instr = '/instruction """\n' + \
              instr[13:].replace('\\n', '\n') + '\n' + \
              '"""'
      writefile(autosave_file, instr+'\n', 'a')
    for instr in conversation:
      writefile(autosave_file, '/conversation ' +instr.replace('\n','\\n')+'\n', 'a')
    if os.path.exists(dv_filename): os.replace(dv_filename, dv_filename+'~')
    os.rename(autosave_file, dv_filename)
  except Exception as saveerr:
    printerr(f'Error renaming {autosave_file} to {dv_filename}: {str(saveerr)}')


def orderly_exit():
  """ Exit script nicely -----------------------------------------------------"""
  #global AutoSave
  if AutoSave: autoSave(ConvFile)
  print(Style.RESET_ALL if UseColor() else '')
  if Verbose: printinfo(f'Exiting {ScriptName} {ConvFile}')
  sys.exit()


#-----------------------------------------------------------------------------
if __name__ == '__main__':
  conversation = []
  while True:
    if len(cmdTypeAhead)==0 and cmdExit: sys.exit()
    getScreenColumns()
    if len(cmdTypeAhead) > 0:
      userInput = cmdTypeAhead.pop(0)
      if userInput[0].rstrip() == '#' or userInput.strip() == '': continue
      if cmdEcho and (userInput[0:5] != '/echo' and userInput[0:5] != '!echo'):
        printstd(USER_NAME+':', color=Fore.YELLOW+Style.BRIGHT)
        print(userInput)
    else:
      cmdEcho = True
      printstd(f'{len(conversation)+1:d}. {USER_NAME}:', color=Fore.YELLOW+Style.BRIGHT)
      try:
        userInput = input().lstrip()
      except KeyboardInterrupt:
        orderly_exit()

    if userInput.strip() == '' or userInput[0].rstrip() == '#': continue

    # Process commands
    if userInput[0] == '!' or userInput[0] == '/':
      cmd = userInput[1:].strip()
      tok = cmd.split()

      # help
      if len(tok) == 0: cmd_help(); continue

      tok[0] = tok[0].lower()

      # man page - README.md
      if tok[0] == 'help' or tok[0] == '?' or tok[0] == '!' or tok[0] == '/':
        subprocess.run(['man', 'dv'], check=False)
        continue

      # exit
      if tok[0] == 'exit' or tok[0] == 'quit':
        orderly_exit()
        continue

      if tok[0] == 'echo':
        if len(tok) > 1:
          tok[1] = tok[1].lower()
          if tok[1] == '1' or tok[1] == 'on' or tok[1] == 'true':
            cmdEcho = True
          elif tok[1] == '0' or tok[1] == 'off' or tok[1] == 'false':
            cmdEcho = False
        else: printinfo('Command Echo is '+str('On' if cmdEcho else 'Off'))
        continue

      if tok[0] == 'auto' or tok[0] == 'autosave':
        if len(tok) > 1:
          tok[1] = tok[1].lower()
          if tok[1] == '1' or tok[1] == 'on' or tok[1] == 'true':
            AutoSave = True
          elif tok[1] == '0' or tok[1] == 'off' or tok[1] == 'false':
            AutoSave = False
        else: printinfo('AutoSave is '+str('On' if AutoSave else 'Off'))
        continue

      # files
      if tok[0] == 'file' or tok[0] == 'files':
        tmp = selectFile(['.', dvHome], '*.dv', 'Select File to Edit: ')
        if not tmp: continue
        try:
          subprocess.run(EDITOR +' '+ tmp, shell=True, executable=SHELL, check=False)
        except Exception as e:
          printerr('ERROR in editor.', str(e)); continue
        if input('Run '+tmp+'? y/n ') != 'y': continue
        cmdTypeAhead = [ '/run ' + tmp ]
        continue

      # edit
      if tok[0] == 'edit':
        modify_datestamp = os.path.getmtime(ConvFile)
        try:
          subprocess.run(f'{EDITOR} {ConvFile}', shell=True, executable=SHELL, check=False)
        except Exception as e:
          printerr('Edit error '+str(e)); continue
        if modify_datestamp != os.path.getmtime(ConvFile):
          if input(f'Re-Load {ConvFile}? y/n ') == 'y':
            cmdTypeAhead = [ '/run ' + ConvFile ]
        continue

      # exec
      if tok[0] == 'exec':
        try:
          subprocess.run(' '.join(tok[1:]), shell=True, executable=SHELL, check=False)
        except Exception as e:
          printerr('Exec error '+str(e))
        continue

      # status
      if tok[0] == 'stat' or tok[0] == 'status':
        longstatus = True
        if len(tok) > 1:
          if tok[1] == 'short': longstatus = False
        cmdstatus(longstatus)
        continue

      # username
      if tok[0] == 'user' or tok[0] == 'user_name':
        if len(tok) > 1:
          tmp = re.sub(r'[^a-zA-Z0-9_-]', '', '-'.join(tok[1:])).strip().upper()
          if len(tmp) < 4 or len(tmp) > 16:
            printerr('Invalid length in user_name "'+tmp+'". Min 4, Max 16.')
            continue
          USER_NAME = tmp
        elif cmdEcho: printinfo('USER_NAME is now '+USER_NAME)
        continue
      # ai_name
      if tok[0] == 'ai_n' or tok[0] == 'ai_name':
        if len(tok) > 1:
          tmp = re.sub(r'[^a-zA-Z0-9_-]', '', '-'.join(tok[1:])).strip().upper()
          if len(tmp) < 4 or len(tmp) > 16:
            printerr('Invalid length in ai_name "'+tmp+'". Min 4, Max 16.')
            continue
          AI_NAME = tmp
        elif cmdEcho: printinfo('AI_NAME is now '+AI_NAME)
        continue
      #engine=text-davinci-003
      if tok[0] == 'engi' or tok[0] == 'engine':
        if len(tok) > 1:
          engine = tok[1]
        elif cmdEcho: printinfo('Engine is now '+engine)
        continue
      # temperature
      if tok[0] == 'temp' or tok[0] == 'temperature':
        if len(tok) > 1 and is_num(tok[1]):
          temperature = max(0.0, min(1.0, float(tok[1])))
        elif cmdEcho: printinfo('Temperature is now '+str(temperature))
        continue
      #top_p=1.0
      if tok[0] == 'top_' or tok[0] == 'top_p':
        if len(tok) > 1 and is_num(tok[1]):
          top_p = max(0.0, min(1.0, float(tok[1])))
        elif cmdEcho: printinfo('Top_p is now '+str(top_p))
        continue
      #tokens=4096
      if tok[0] == 'toke' or tok[0] == 'tokens':
        if len(tok) > 1 and is_num(tok[1]):
          tokens = max(16, min(4096, int(tok[1])))
        elif cmdEcho: printinfo('Tokens is now '+str(tokens))
        continue
      #freq_pen=0.0
      if tok[0] == 'freq' or tok[0] == 'freq_pen':
        if len(tok) > 1 and is_num(tok[1]):
          freq_pen = max(-2, min(2, float(tok[1])))
        elif cmdEcho: printinfo('Freq_pen is now '+str(freq_pen))
        continue
      #pres_pen=0.0
      if tok[0] == 'pres' or tok[0] == 'pres_pen':
        if len(tok) > 1 and is_num(tok[1]):
          pres_pen = max(-2, min(2, float(tok[1])))
        elif cmdEcho: printinfo('Pres_pen is now '+str(pres_pen))
        continue

      # prompt [newprompt]
      if tok[0] == 'prom' or tok[0] == 'prompt':
        if len(tok) > 1:
          Prompt = ' '.join(tok[1:]).replace('\\n', '\n').strip()
        elif cmdEcho: printinfo(Prompt, prefix='')
        continue

      # conversation [conversation]
      if tok[0] == 'conv' or tok[0] == 'conversation':
        if len(tok) > 1:
          conversation.append(' '.join(tok[1:]).replace('\\n', '\n'))
        else:
          for tmp in conversation:
            printinfo(tmp, prefix='')
        continue

      # list [0-0]
      if tok[0] == 'list':
        short = False
        if len(tok) > 1:
          if   tok[1][0:4] == 'shor': short = True; tok.pop(1)
          elif tok[1][0:4] == 'long': short = False; tok.pop(1)
        if len(tok) < 2: tok.append('all')
        rnge = int_list(tok[1:], 1, len(conversation), False)
        if not rnge: continue
        for r in rnge:
          text = conversation[r-1].replace('<<USER_NAME>>', USER_NAME).replace('<<AI_NAME>>', AI_NAME)
          if text[0:len(USER_NAME)+2] == USER_NAME+': ':
            printstd(f'{r:d}. {USER_NAME}:', color=Fore.YELLOW, style=Style.DIM)
            text = text[len(USER_NAME)+2:]
          elif text[0:len(AI_NAME)+2] == AI_NAME+': ':
            printstd(f'{r:d}. {AI_NAME}:', color=Fore.GREEN, style=Style.DIM)
            text = text[len(AI_NAME)+2:] +'\n\n'
          for _line in text.splitlines():
            if short:
              printinfo(_line[0:ScreenColumns-3]+'...',prefix='')
              break
            printinfo(textwrap.fill(_line, width=ScreenColumns), prefix='')
        continue

      # clear
      if tok[0] == 'clea' or tok[0] == 'clear':
        conversation = []
        continue

      # delete [0-0]
      if tok[0] == 'dele' or tok[0] == 'delete':
        if len(tok) < 2: continue
        rnge = int_list(tok[1:], 1, len(conversation), True)
        if not rnge: continue
        i = int(0)
        for r in rnge:
          del conversation[r-1]
          i += 1
        if cmdEcho: printinfo(f'{i:d} entries deleted')
        continue

      # tldr [range]
      if tok[0] == 'tldr' or tok[0] == 'tl;dr':
        if len(tok) < 2: tok.append(str(len(conversation)))
        rnge = int_list(tok[1:], 1, len(conversation), False)
        if not rnge: continue
        i=0
        for r in rnge:
          text = conversation[r-1]
          if text[0:13] != '<<AI_NAME>>: ': continue
          text = text.replace('<<AI_NAME>>', AI_NAME).replace('<<USER_NAME>>', USER_NAME)
          try:
            tldr_response = gpt3_completion(text+'\n\nTL;DR: ', engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
            if tldr_response == '': continue
          except:
            printerr('GPT-3 experienced an error. Possibly overloaded.')
            continue
          printstd(AI_NAME+' TL;DR'+ ('' if len(rnge)==1 else '['+str(i+1)+']') + ':', color=Fore.GREEN)
          printinfo(tldr_response, prefix='')
          conversation.append(f'<<AI_NAME>>: {tldr_response}')
          i+=1
        continue

      # save [file]
      if tok[0] == 'save':
        if len(tok) < 2: filename = ConvFile
        else: filename = tok[1].replace('"', '').replace('"', '')
        filename = find_dv_file(filename, mustexist=False)
        if os.path.exists(filename):
          try:
            userInput = input(f'\n{filename} exists. Overwrite? (y/n) ')
            if userInput != 'y': continue
          except KeyboardInterrupt: continue
        p = f'engine={engine}\ntemperature={temperature:f}\ntop_p={top_p:f}\ntokens=4096\nfreq_pen={freq_pen:f}\npres_pen={pres_pen:f}\nAI_NAME={AI_NAME}\nUSER_NAME={USER_NAME}\n'
        try:
          writefile(filename,
            p+'prompt=\n' \
             + PromptReplace('\n'.join(conversation),AI_NAME,'<<AI_NAME>>',USER_NAME,'<<USER_NAME>>').strip() \
             + '\n')
        except Exception as e:
          printerr('Error writing to ' + filename, str(e))
          continue
        if cmdEcho: printinfo('Session saved to ' + filename)
        continue

      if tok[0] == 'vars' or tok[0] == 'locals':
        varsearch = tok[1] if len(tok) > 1 else ''
        locals_list = [(key, value) for key, value in locals().items() if not callable(value)]
        for key, value in locals_list:
          value = str(value).replace('\n','\\n')
          if value[0:7] == '<module': continue
          if varsearch and key[0:len(varsearch)] != varsearch: continue
          print(f"{key}={value}")
        print('sys.path=', sys.path)
        print()
        print('Environment:')
        for env in ['USER', 'HOME', 'SHELL', 'EDITOR', 'BROWSER', 'TMPDIR', 'PATH', 'OPENAI_API_KEY', 'OPENAI_ORGANIZATION_ID']:
          print(f'{env}={str(os.getenv(env))}')
        continue

      # history
      if tok[0] == 'hist' or tok[0] == 'history':
        if len(tok) > 1:
          if is_num(tok[1][0]):
            rnge = int_list(tok[1:], 1, readline.get_current_history_length(), False)
            if not rnge: continue
            for r in rnge:
              cmdTypeAhead.append(readline.get_history_item(int(r)))
          else:
            printerr(f'Unknown parameter {tok[1]}.')
          continue
        history_length = readline.get_current_history_length()
        prev_item = ''
        for i in range(history_length, 0, -1):
          item = readline.get_history_item(i)
          if len(item) <= 2:
            readline.remove_history_item(i-1)
            continue
          if item == prev_item:
            readline.remove_history_item(i-1)
            continue
          prev_item = item            
        history_length = readline.get_current_history_length()
        for i in range(1, history_length+1):
          print(i, readline.get_history_item(i))
        continue

      # awesome gpt prompts
      if tok[0] == 'awes' or tok[0] == 'awesome':
        curdir = os.getcwd()
        os.chdir(ScriptDir)
        awe_prompt = select_awesome_prompt(tok[0:])
        os.chdir(curdir)
        if awe_prompt == '': continue
        print(awe_prompt)
        userInput = awe_prompt

      # run
      elif tok[0] == 'run':
        if len(tok) < 2:
          file = selectFile(['.', dvHome], '*.dv', 'Select dvScript to Run: ')
          if not file: continue
        else:
          file = find_dv_file(' '.join(tok[1:]), mustexist=True)
          if file == '':
            printerr(f'dvScript {file} does not exist.')
            continue
        try:
          readline.write_history_file(historyFile)
          read_dvfile(file)
          ConvFile = file
          historyFile = initHistory(ConvFile)
        except Exception:
          printerr(f'Run failed for {file}. Reloading {ConvFile}.')
          read_dvfile(ConvFile)
          historyFile = initHistory(ConvFile)
        continue

      # instruction [instruction]
      elif tok[0] == 'inst' or tok[0] == 'instruction':
        if len(tok) > 1:
          userInput = ' '.join(tok[1:]).replace('\\n', '\n').strip()
        else:
          for tmp in Instructions:
            if tmp[0:8] == '/prompt ' or tmp[0:8] == '!prompt ':
              tmp = '/prompt """\n' + \
                    tmp[8:].replace('\\n', '\n') + \
                    '"""'
            elif tmp[0:13] == '/instruction ' or tmp[0:13] == '!instruction ':
              tmp = '/instruction """\n' + \
                    tmp[13:].replace('\\n', '\n') + '\n' + \
                    '"""'
            printinfo(tmp, prefix='')
          continue
        # proceed to gpt

      # import file
      elif tok[0] == 'impo' or tok[0] == 'import':
        if len(tok) < 2:
          tmpfile = tempname('command', '.dv')
          writefile(tmpfile, '')
          while True:
            try:
              subprocess.run(f'{EDITOR} {tmpfile}', shell=True, executable=SHELL, check=False)
            except Exception as e:
              printerr('Import file error.', str(e))
              userInput = ''
              break
            userInput = readfile(tmpfile)
            if not userInput: break
            while True:
              ynr = input(f'Execute instructions in {tmpfile}? yes/no/re-edit ').lower()
              if ynr in ['y', 'n', 'r']: break
              printerr('Valid input y, n, or r.')
            if ynr == 'y': break
            if ynr == 'r': continue
            userInput = ''
            break
          try:
            os.remove(tmpfile)
            os.remove(tmpfile+'~')
          except FileNotFoundError: pass
          if not userInput: continue
          print('\n' + userInput.strip())
        # proceed to gpt

        else:
          filename = tok[1]
          if not os.path.exists(filename):
            printerr(filename+' does not exist.')
            continue
          if cmdEcho: printinfo('Importing from text file '+filename)
          userInput = readfile(filename).strip()+'\n'
        # proceed to gpt

      # summarise
      elif tok[0] == 'summ' or tok[0] == 'summarize' or tok[0] == 'summarise':
        if len(tok) < 2: what = 'conversation'
        else: what = tok[1]
        if what[0:4] == 'prom' or what == 'prompt':
          userInput = PromptReplace('') \
              + f'\n\n{USER_NAME}: Write a detailed summary of all the above: '
        elif what[0:4] == 'conv' or what == 'conversation':
          userInput = text_block \
              + f'\n\n{USER_NAME}: Write a detailed summary of all the above: '
        elif what == 'all':
          userInput = PromptReplace(text_block) \
              + f'\n\n{USER_NAME}: Write a detailed summary of all the above: '
        else:
          printerr('Invalid option. Valid options for /summarize are prompt|conv|all.')
          continue
        # proceed to gpt

      # invalid command
      else:
        printerr('Invalid command: /' + cmd)
        if Verbose: printinfo("Enter '/help' for command help")
        continue

    # Prepend username to user input
    conversation.append(f'<<USER_NAME>>: {userInput}')
    # Aggregate the entire conversation
    text_block = ('\n'.join(conversation)).strip()
    # Send the entire conversation to GPT-3
    try:
      response = gpt3_completion(PromptReplace(text_block)+'\n'+AI_NAME+': ', \
            engine, temperature, top_p, tokens, freq_pen, pres_pen, stop)
      if response == '':
        conversation.pop()
        continue
    except:
      printerr('GPT-3 experienced an error. Possibly overloaded.')
      conversation.pop()
      continue
    # Add the response to the conversation list
    conversation.append(f'<<AI_NAME>>: {response}')
    # Print the response from GPT-3
    printstd(f'{len(conversation):d}. {AI_NAME}:', color=Fore.GREEN)
    for _line in response.splitlines():
      print(textwrap.fill(_line, width=ScreenColumns))

    # eg, devaju -x -c 'command'
    if len(cmdTypeAhead)==0 and cmdExit: sys.exit()
#end
